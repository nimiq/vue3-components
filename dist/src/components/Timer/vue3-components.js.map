{"version":3,"file":"vue3-components.js","sources":["../../../../src/components/Timer/Timer.vue"],"sourcesContent":["<template>\n    <Tooltip class=\"timer\" ref=\"root$\"\n        v-bind=\"{\n            preferredPosition: 'bottom right',\n            theme: theme === TimerThemes.INVERSE || theme  === TimerThemes.WHITE ? TooltipThemes.INVERSE : TooltipThemes.NORMAL,\n            ...tooltipProps,\n            styles: {\n                width: '18.25rem',\n                pointerEvents: 'none',\n                ...(tooltipProps ? tooltipProps.styles : undefined),\n            },\n        }\"\n        @show=\"detailsShown = true\"\n        @hide=\"detailsShown = false\"\n        :class=\"{\n            'time-shown': detailsShown || alwaysShowTime,\n            'little-time-left': progress >= .75,\n            'inverse-theme': theme === TimerThemes.INVERSE,\n            'white-theme': theme === TimerThemes.WHITE,\n        }\"\n    >\n        <template #trigger>\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 26 26\">\n                <circle ref=\"time-circle\" class=\"time-circle\" cx=\"50%\" cy=\"50%\" :r=\"radius.currentValue\"\n                    :stroke-dasharray=\"`${timeCircleInfo.length} ${timeCircleInfo.gap}`\"\n                    :stroke-dashoffset=\"timeCircleInfo.offset\"\n                    :stroke-width=\"timeCircleInfo.strokeWidth\"></circle>\n                <circle class=\"filler-circle\" cx=\"50%\" cy=\"50%\" :r=\"radius.currentValue\"\n                    :stroke-dasharray=\"`${fillerCircleInfo.length} ${fillerCircleInfo.gap}`\"\n                    :stroke-dashoffset=\"fillerCircleInfo.offset\"\n                    :stroke-width=\"fillerCircleInfo.strokeWidth\"></circle>\n\n                <transition name=\"transition-fade\">\n                    <g v-if=\"!detailsShown && !alwaysShowTime\" class=\"info-exclamation-icon\">\n                        <rect x=\"12\" y=\"9\" width=\"2\" height=\"2\" rx=\"1\" />\n                        <rect x=\"12\" y=\"12.5\" width=\"2\" height=\"4.5\" rx=\"1\" />\n                    </g>\n                    <text v-else class=\"countdown\" x=\"50%\" y=\"50%\">\n                        {{  toSimplifiedTime(timeLeftRef, false, maxUnit) }}\n                    </text>\n                </transition>\n            </svg>\n        </template>\n        <template #default>\n            <I18n path=\"This offer expires in {timer}.\" componentName=\"Timer\">\n                <template #timer>{{ toSimplifiedTime(timeLeftRef, true, maxUnit) }}</template>\n            </I18n>\n        </template>\n    </Tooltip>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, onMounted, onUnmounted, ref, watch } from 'vue';\nimport { Tweenable } from '@nimiq/utils';\nimport Tooltip, { TooltipThemes } from '../Tooltip/Tooltip.vue';\nimport I18n from '../../i18n/I18n';\nimport { loadI18n } from '../../i18n/I18nComposable';\n\nexport interface CircleInfo {\n    length: number;\n    lengthWithLineCaps: number;\n    gap: number;\n    offset: number;\n    strokeWidth: number;\n}\n\nconst TIME_STEPS = [\n    { unit: 'minute', factor: 60 },\n    { unit: 'hour', factor: 60 },\n    { unit: 'day', factor: 24 },\n];\n\nfunction toSimplifiedTime(millis: number, includeUnit?: true, maxUnit?: string): string;\nfunction toSimplifiedTime(millis: number, includeUnit: false, maxUnit?: string): number;\nfunction toSimplifiedTime(millis: number, includeUnit: boolean = true, maxUnit?: string): number | string {\n    // find appropriate unit, starting with second\n    let resultTime = millis / 1000;\n    let resultUnit = 'second';\n    for (const { unit, factor } of TIME_STEPS) {\n        if (resultTime / factor < 1 || resultUnit === maxUnit) break;\n        resultTime /= factor;\n        resultUnit = unit;\n    }\n\n    resultTime = Math.floor(resultTime);\n    if (!includeUnit) {\n        return resultTime;\n    } else {\n        const $t = loadI18n('Timer');\n\n        const i18nTime = {\n            get second() { return $t('second'); },\n            get seconds() { return $t('seconds'); },\n            get minute() { return $t('minute'); },\n            get minutes() { return $t('minutes'); },\n            get hour() { return $t('hour'); },\n            get hours() { return $t('hours'); },\n            get day() { return $t('day'); },\n            get days() { return $t('days'); },\n        };\n\n        resultUnit = i18nTime[`${resultUnit}${resultTime !== 1 ? 's' : ''}` as (keyof typeof i18nTime)];\n        return `${resultTime} ${resultUnit}`;\n    }\n}\n\nconst TIMER_REM_FACTOR = 8; // size of 1rem\nconst TIMER_BASE_SIZE = 3.25 * TIMER_REM_FACTOR;\nconst TIMER_BASE_RADIUS = TIMER_REM_FACTOR;\nconst TIMER_RADIUS_GROWTH_FACTOR = 1.5;\n\nexport enum TimerEvents {\n    END = 'end',\n}\n\nexport enum TimerThemes {\n    NORMAL = 'normal',\n    INVERSE = 'inverse',\n    WHITE = 'white',\n}\n\nexport default defineComponent({\n    name: 'Timer',\n    // extends: I18nMixin,\n    props: {\n        startTime: Number,\n        endTime: Number,\n        alwaysShowTime: {\n            type: Boolean,\n            default: true,\n        },\n        theme: {\n            type: String,\n            default: 'normal',\n            validator: (value: any) => Object.values(TimerThemes).includes(value),\n        },\n        strokeWidth: {\n            type: Number,\n            default: 2,\n        },\n        tooltipProps: Object,\n        maxUnit: {\n            type: String,\n            required: false,\n            validator: (value: any) => [undefined, 'second', 'minute', 'hour', 'day'].includes(value),\n        },\n    },\n    setup(props, context) {\n        const root$ = ref<typeof Tooltip | null>(null);\n\n        const timeOffset = ref(0);\n        const sampledTime = ref(0);\n        const detailsShown = ref(false);\n        // While the radius r of the circle and the values stroke-dasharray, stroke-dashoffset and stroke-width that depend\n        // on the radius can be transitioned via css, the behavior on value update during an ongoing transition is not\n        // consistent (e.g. time update while animating on user hover or quick hover and unhover). Therefore animate via JS.\n        const radius: Tweenable = new Tweenable(detailsShown.value || props.alwaysShowTime\n            ? TIMER_BASE_RADIUS * TIMER_RADIUS_GROWTH_FACTOR\n            : TIMER_BASE_RADIUS);\n        const fullCircleLength = ref(2 * Math.PI * radius.currentValue);\n        const timeoutId = ref<number | null>(null);\n        const updateTimeoutId = ref<number | null>(null);\n        const requestAnimationFrameId = ref<number | null>(null);\n        const size = ref(TIMER_BASE_SIZE);\n\n        function synchronize(referenceTime: number) {\n            timeOffset.value = referenceTime - Date.now();\n        }\n\n        context.expose({ synchronize });\n\n        onMounted(() => {\n            requestAnimationFrame(() => size.value = root$.value!.offsetWidth); // in rAF to avoid forced reflow\n            // this.onResize = this.onResize.bind(this); // TODO: do we still need this?\n            window.addEventListener('resize', onResize);\n        });\n\n        onUnmounted(() => {\n            if (timeoutId.value) clearTimeout(timeoutId.value);\n            if (updateTimeoutId.value) clearTimeout(updateTimeoutId.value);\n            if (requestAnimationFrameId.value) cancelAnimationFrame(requestAnimationFrameId.value);\n            window.removeEventListener('resize', onResize);\n        });\n\n        const totalTimeRef = computed(() => {\n            if (props.startTime === undefined || props.endTime === undefined) {\n                return 0;\n            } else {\n                return Math.max(0, props.endTime - props.startTime);\n            }\n        });\n\n        const timeLeftRef = computed(() => {\n            if (props.startTime === undefined || props.endTime === undefined) {\n                return 0;\n            } else {\n                return Math.max(0, Math.min(totalTimeRef.value, props.endTime - sampledTime.value));\n            }\n        });\n\n        const progress = computed(() => {\n            if (props.startTime === undefined || props.endTime === undefined || totalTimeRef.value === 0) {\n                return 0;\n            } else {\n                return 1 - timeLeftRef.value / totalTimeRef.value;\n            }\n        });\n\n        const timeCircleInfo = computed<CircleInfo>(() => {\n            // Have a max length to make it more recognizable that this is a timer by never rendering a full circle.\n            // The rounded stroke ending rendered with radius strokeWidth/2 does not count towards the stroke length,\n            // therefore to get the desired gap of 1.5 strokeWidths, we use 2.5 strokeWidths.\n            const maxLength = fullCircleLength.value - 2.5 * props.strokeWidth;\n            const length = Math.min(maxLength, (1 - progress.value) * fullCircleLength.value);\n            const lengthWithLineCaps = length + props.strokeWidth; // add line caps with strokeWidth/2 radius\n            const gap = fullCircleLength.value - length;\n            // The path grows clockwise starting on the right side. Offset by 90 degrees and gap to let path start with gap\n            // and end on top.\n            const offset = fullCircleLength.value / 4 - gap;\n            return { length, lengthWithLineCaps, gap, offset, strokeWidth: props.strokeWidth };\n        });\n\n        const fillerCircleInfo = computed<CircleInfo>(() => {\n            // Filler circle should be rendered in the gap left by the time circle with a margin of strokeWidth. If there\n            // is not enough space, compensate by reducing the filler circle stroke width.\n            const availableSpace = fullCircleLength.value - timeCircleInfo.value.lengthWithLineCaps - 2 * props.strokeWidth;\n            const lengthWithLineCaps = Math.max(0, availableSpace);\n            const strokeWidth = Math.min(props.strokeWidth, lengthWithLineCaps);\n            const length = Math.max(0, lengthWithLineCaps - strokeWidth); // subtract rounded line caps\n            const gap = fullCircleLength.value - length;\n            const offset = fullCircleLength.value / 4 // rotate by 90 degrees\n                - props.strokeWidth / 2 // skip rounded line cap of time circle\n                - props.strokeWidth // margin\n                - strokeWidth / 2; // account for our own line cap\n            return { length, lengthWithLineCaps, gap, offset, strokeWidth };\n        });\n\n        function calculateUpdateInterval(): number {\n            // Not a getter / computed prop to avoid unnecessary updates when not needed.\n            const scaleFactor = size.value / TIMER_BASE_SIZE;\n            const circleLengthPixels = fullCircleLength.value * scaleFactor;\n            const steps = circleLengthPixels * 3; // update every .33 pixel change for smooth transitions\n            const minInterval = 1000 / 60; // up to 60 fps\n            // Constrain interval such that we don't skip time steps in the countdown for the respective time unit.\n            const timeLeft = timeLeftRef.value;\n            const totalTime = totalTimeRef.value;\n            const updatesPerTimeStep = 2; // multiple updates per time step to avoid skipping a step by a delayed interval\n            let timeStep = 1000; // starting with seconds\n            let maxInterval = timeStep / updatesPerTimeStep;\n            for (const { factor } of TIME_STEPS) {\n                const nextTimeStep = timeStep * factor;\n                const nextMaxInterval = nextTimeStep / updatesPerTimeStep;\n                const nextInterval = Math.min(nextMaxInterval, Math.max(minInterval, totalTime / steps));\n                if ((timeLeft - nextInterval) / nextTimeStep < 1) {\n                    // If the time left after nextInterval can't be expressed in nextTimeStep as a value >=1, stop. We check\n                    // for the time after the next interval to avoid jumping for example from 70s (displayed as 1 minute)\n                    // directly to 50s if the interval is 20s. Note that the behavior here resembles the one in\n                    // toSimplifiedTime.\n                    if (timeLeft / nextTimeStep > 1) {\n                        // If the value before the interval is still >1 in the next time unit still allow a larger jump than\n                        // at the smaller time unit but set the maxInterval such that we jump no further than where the\n                        // switch to the smaller unit happens, for example jump from 70s to 60s if the interval is 20s.\n                        maxInterval = timeLeft - nextTimeStep;\n                    }\n                    break;\n                }\n                timeStep = nextTimeStep;\n                maxInterval = nextMaxInterval;\n            }\n\n            return Math.min(maxInterval, Math.max(minInterval, totalTimeRef.value / steps));\n        }\n\n        watch(detailsShown, setRadius, { immediate: true });\n        watch(() => props.alwaysShowTime, setRadius);\n\n        function setRadius() {\n            radius.tweenTo(detailsShown.value || props.alwaysShowTime\n                ? TIMER_RADIUS_GROWTH_FACTOR * TIMER_BASE_RADIUS\n                : TIMER_BASE_RADIUS, 300);\n            rerender();\n        }\n\n        watch(() => props.startTime, setTimer, { immediate: true });\n        watch(() => props.endTime, setTimer);\n        watch(timeOffset, setTimer);\n\n        function setTimer() {\n            sampledTime.value = Date.now() + timeOffset.value;\n            if (timeoutId.value) clearTimeout(timeoutId.value);\n            if (props.startTime && props.endTime) {\n                timeoutId.value = window.setTimeout(() => context.emit(TimerEvents.END, props.endTime),\n                    props.endTime - sampledTime.value);\n                rerender();\n            }\n        }\n\n        function rerender() {\n            sampledTime.value = Date.now() + timeOffset.value;\n            fullCircleLength.value = 2 * Math.PI * radius.currentValue;\n\n            if (timeLeftRef.value === 0 && radius.finished) return;\n\n            if (updateTimeoutId.value) clearTimeout(updateTimeoutId.value);\n            if (requestAnimationFrameId.value) cancelAnimationFrame(requestAnimationFrameId.value);\n\n            if (!radius.finished) {\n                // animate radius with high frame rate\n                requestAnimationFrameId.value = requestAnimationFrame(() => rerender());\n            } else {\n                // update with low frame rate\n                updateTimeoutId.value = window.setTimeout(() => rerender(), calculateUpdateInterval());\n            }\n        }\n\n        function onResize() {\n            if (root$.value) size.value = root$.value.offsetWidth;\n        }\n\n        return {\n            toSimplifiedTime,\n\n            TooltipThemes,\n            TimerThemes,\n\n            root$,\n\n            detailsShown,\n            radius,\n\n            timeLeftRef,\n            progress,\n            timeCircleInfo,\n            fillerCircleInfo,\n        };\n    },\n    components: { Tooltip, I18n },\n})\n</script>\n\n<style scoped>\n    .timer {\n        width: 3.25rem;\n        position: relative;\n    }\n\n    /* for setting height automatically depending on width */\n    .timer::before {\n        content: '';\n        padding-top: 100%;\n        display: block;\n    }\n\n    .tooltip:deep(.trigger),\n    svg {\n        display: block;\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    svg {\n        fill: none;\n        stroke-linecap: round;\n    }\n\n    circle {\n        stroke: var(--nimiq-blue);\n        transition: stroke .3s var(--nimiq-ease), opacity .3s var(--nimiq-ease);\n    }\n\n    .inverse-theme circle,\n    .white-theme circle {\n        stroke: white;\n    }\n\n    .filler-circle {\n        opacity: .2;\n    }\n\n    .time-circle {\n        opacity: .3;\n    }\n\n    .time-shown .time-circle {\n        stroke: var(--nimiq-light-blue);\n        opacity: 1;\n    }\n\n    .inverse-theme.time-shown:not(.little-time-left) .time-circle {\n        stroke: var(--nimiq-light-blue-on-dark, var(--nimiq-light-blue));\n    }\n\n    .white-theme.time-shown:not(.little-time-left) .time-circle {\n        stroke: rgba(255, 255, 255, 0.4);\n    }\n\n    /* .inverse-theme.time-shown .filler-circle,\n    .white-theme.time-shown .filler-circle {\n        opacity: 0;\n    } */\n\n    .little-time-left .time-circle {\n        stroke: var(--nimiq-orange);\n        opacity: 1;\n    }\n\n    .info-exclamation-icon {\n        fill: var(--nimiq-blue);\n        opacity: .4;\n        transform-origin: center;\n        transition: fill .3s var(--nimiq-ease), opacity .3s var(--nimiq-ease), transform .3s var(--nimiq-ease);\n    }\n\n    .inverse-theme .info-exclamation-icon,\n    .white-theme .info-exclamation-icon {\n        fill: white;\n    }\n\n    .little-time-left .info-exclamation-icon {\n        fill: var(--nimiq-orange);\n        opacity: 1;\n        transform: rotate(180deg); /* turn info icon into an exclamation mark */\n    }\n\n    .countdown {\n        font-size: 12px; /* relative to svg viewBox */\n        font-weight: bold;\n        text-anchor: middle;\n        dominant-baseline: central;\n        fill: var(--nimiq-light-blue);\n        transition: fill .3s var(--nimiq-ease);\n    }\n\n    .inverse-theme .countdown {\n        fill: var(--nimiq-light-blue-on-dark, var(--nimiq-light-blue));\n    }\n\n    .white-theme .countdown {\n        fill: rgba(255, 255, 255, 0.6);\n    }\n\n    .little-time-left .countdown {\n        fill: var(--nimiq-orange);\n    }\n\n    .transition-fade-enter-active,\n    .transition-fade-leave-active {\n        transition: opacity .3s var(--nimiq-ease);\n    }\n\n    .transition-fade-enter,\n    .transition-fade-leave-to {\n        opacity: 0 !important;\n    }\n</style>\n"],"names":["_withScopeId","n","_pushScopeId","_popScopeId","_hoisted_1","_hoisted_4","_hoisted_5","_createElementVNode","_hoisted_6","_hoisted_7","_hoisted_8","_resolveComponent","_openBlock","_createBlock","_component_Tooltip","_mergeProps","_ctx","_cache","$event","_withCtx","_createElementBlock","_hoisted_2","_hoisted_3","_createVNode","_Transition","_toDisplayString","_component_I18n"],"mappings":";;;;;AAsBiB,MAAAA,IAAM,CAA4BC,OAAAC,EAAA,iBAAA,GAAAD,IAAAA,KAAAE,KAAAF,IAACG,IAAQ;AAAA,EAAA,OAAA;AAAA;2IAWGC,IAAM;AAAA,EAAA,KAAA;AAAA;GAC9BC,IAAG,gBAAAN,EAAA,MAAAO,gBAAAA,EAAA,QAAA;AAAA,EAAC,GAAA;AAAA,EAAU,GAAA;AAAA,EAAW,OAAM;AAAA,EAAA,QAAA;AAAA;GACvC,MAAK,EAAA,CAAA,GAAGC,IAAM,gBAAAR,EAAA,MAAAO,gBAAAA,EAAA,QAAA;AAAA,EAAC,GAAA;AAAA,EAAU,GAAA;AAAA,EAAa,OAAM;AAAA,EAAA,QAAA;AAAA;GADnD,MAAiD,EAAA,CAAA,GACjDE,IAAsD;AAAA,EAAAH;AAAA;GAE7CI,IAAM;AAAA,EAAY,KAAE;AAAA,EAAM,OAAE;AAAA,EAAA,GAAA;AAAA;;;2BApCzDC,EA+CU,SAAA;SA/CiBC,EAAO,GAAAC,EAAAC,GAAAC,EAAA;AAAA,IAAA,OAAA;AAAA;;IAC2K,mBAAA;AAAA,IAAA,OAAAC,EAAA,UAAAA,EAAA,YAAA,WAAAA,EAAA,UAAAA,EAAA,YAAA,QAAAA,EAAA,cAAA,UAAAA,EAAA,cAAA;AAAA;;MAAkI,OAAA;AAAA,MAAA,eAAA;AAAA;IAUtU;AAAA,EAAA,GACA;AAAA,IACJ,QAAKC,EAAA,OAAAA,EAAA,KAAA,CAAAC,MAAAF,EAAA,eAAA;AAAA,IAAA,QAAAC,EAAA,OAA8BA,cAAgBD,EAAc,eAAA;AAAA,IAAA,OAAA;AAAA,sBAAgF,gBAAUA,EAAA;AAAA,MAAA,oBAAgDA,EAAK,YAAK;AAAA,MAAA,iBAAAA,EAAA,UAAAA,EAAA,YAAA;AAAA;IAO3M;AAAA,EAAA,CAAA,GAAA;AAAA,aAEHG,EAGwD,MAAA;AAAA,OAAAP,KAH/BQ,EAAA,OAAAhB,GAAA;AAAA,QAAAG,EAAO,UAAa;AAAA,UAAC,KAAG;AAAA,UAAM,OAAG;AAAA,UAAO,IAAG;AAAA,UAC/D,IAAA;AAAA,UACA,GAAAS,EAAA,OAAA;AAAA,UACA,oBAAc,oBAAe,UAAWA,EAAA,eAAA;AAAA,UAAA,qBAAAA,EAAA,eAAA;AAAA,UAC7C,gBAG0DA,EAAA,eAAA;AAAA,QAAA,GAHlD,MAAM,GAAAK,CAAA;AAAA,QAAwBd,EAAA,UAAA;AAAA,UAAC,OAAG;AAAA,UAAO,IAAG;AAAA,UAC/C,IAAA;AAAA,UACA,GAAAS,EAAA,OAAA;AAAA,UACA,oBAAc,sBAAiB,UAAWA,EAAA,iBAAA;AAAA,UAAA,qBAAAA,EAAA,iBAAA;AAAA,UAE/C,gBAQaA,EARI,iBAAA;AAAA,QAAA,GAIT,MAAA,GAAAM,CAAA;AAAA,QAHMC,EAAAC,GAAY,EAAK,MAAc,kBAAA,GAAA;AAAA,UAAzC,SAAAL,EAAA,MAAA;AAAA,YAIA,CAAAH,EAAA,gBAAA,CAAAA,EAAA,kBAAAJ,KAAAQ,EAAA,KAAAf,GAAAI,CAAA,MAAAG,EAAA,GAAAQ,EAAA,QAAAV,GAAAe,EAAAT,EAAA,iBAAAA,EAAA,aAAA,IAAAA,EAAA,OAAA,CAAA,GAAA,CAAA;AAAA;;;MAMD,CAAA;AAAA,IAAA,CAAA;AAAA,aACGG,EAAC,MAAA;AAAA,MAAAI,EAAiCG,GAAqB;AAAA,QAAA,MAAA;AAAA,QAClD,eAAK;AAAA,MAAA,GAAA;AAAA;;;;;;;;;;"}