{"version":3,"file":"vue3-components2.js","sources":["../../../../src/components/Timer/Timer.vue"],"sourcesContent":["<template>\n    <Tooltip class=\"timer\" ref=\"root$\"\n        v-bind=\"{\n            preferredPosition: 'bottom right',\n            theme: theme === TimerThemes.INVERSE || theme  === TimerThemes.WHITE ? TooltipThemes.INVERSE : TooltipThemes.NORMAL,\n            ...tooltipProps,\n            styles: {\n                width: '18.25rem',\n                pointerEvents: 'none',\n                ...(tooltipProps ? tooltipProps.styles : undefined),\n            },\n        }\"\n        @show=\"detailsShown = true\"\n        @hide=\"detailsShown = false\"\n        :class=\"{\n            'time-shown': detailsShown || alwaysShowTime,\n            'little-time-left': progress >= .75,\n            'inverse-theme': theme === TimerThemes.INVERSE,\n            'white-theme': theme === TimerThemes.WHITE,\n        }\"\n    >\n        <template #trigger>\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 26 26\">\n                <circle ref=\"time-circle\" class=\"time-circle\" cx=\"50%\" cy=\"50%\" :r=\"radius.currentValue\"\n                    :stroke-dasharray=\"`${timeCircleInfo.length} ${timeCircleInfo.gap}`\"\n                    :stroke-dashoffset=\"timeCircleInfo.offset\"\n                    :stroke-width=\"timeCircleInfo.strokeWidth\"></circle>\n                <circle class=\"filler-circle\" cx=\"50%\" cy=\"50%\" :r=\"radius.currentValue\"\n                    :stroke-dasharray=\"`${fillerCircleInfo.length} ${fillerCircleInfo.gap}`\"\n                    :stroke-dashoffset=\"fillerCircleInfo.offset\"\n                    :stroke-width=\"fillerCircleInfo.strokeWidth\"></circle>\n\n                <transition name=\"transition-fade\">\n                    <g v-if=\"!detailsShown && !alwaysShowTime\" class=\"info-exclamation-icon\">\n                        <rect x=\"12\" y=\"9\" width=\"2\" height=\"2\" rx=\"1\" />\n                        <rect x=\"12\" y=\"12.5\" width=\"2\" height=\"4.5\" rx=\"1\" />\n                    </g>\n                    <text v-else class=\"countdown\" x=\"50%\" y=\"50%\">\n                        {{  toSimplifiedTime(timeLeftRef, false, maxUnit) }}\n                    </text>\n                </transition>\n            </svg>\n        </template>\n        <template #default>\n            <I18n path=\"This offer expires in {timer}.\" componentName=\"Timer\">\n                <template #timer>{{ toSimplifiedTime(timeLeftRef, true, maxUnit) }}</template>\n            </I18n>\n        </template>\n    </Tooltip>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, onMounted, onUnmounted, ref, watch } from 'vue';\nimport { Tweenable } from '@nimiq/utils';\nimport Tooltip, { TooltipThemes } from '../Tooltip/Tooltip.vue';\nimport I18n from '../../i18n/I18n';\nimport { loadI18n } from '../../i18n/I18nComposable';\n\nexport interface CircleInfo {\n    length: number;\n    lengthWithLineCaps: number;\n    gap: number;\n    offset: number;\n    strokeWidth: number;\n}\n\nconst TIME_STEPS = [\n    { unit: 'minute', factor: 60 },\n    { unit: 'hour', factor: 60 },\n    { unit: 'day', factor: 24 },\n];\n\nfunction toSimplifiedTime(millis: number, includeUnit?: true, maxUnit?: string): string;\nfunction toSimplifiedTime(millis: number, includeUnit: false, maxUnit?: string): number;\nfunction toSimplifiedTime(millis: number, includeUnit: boolean = true, maxUnit?: string): number | string {\n    // find appropriate unit, starting with second\n    let resultTime = millis / 1000;\n    let resultUnit = 'second';\n    for (const { unit, factor } of TIME_STEPS) {\n        if (resultTime / factor < 1 || resultUnit === maxUnit) break;\n        resultTime /= factor;\n        resultUnit = unit;\n    }\n\n    resultTime = Math.floor(resultTime);\n    if (!includeUnit) {\n        return resultTime;\n    } else {\n        const $t = loadI18n('Timer');\n\n        const i18nTime = {\n            get second() { return $t('second'); },\n            get seconds() { return $t('seconds'); },\n            get minute() { return $t('minute'); },\n            get minutes() { return $t('minutes'); },\n            get hour() { return $t('hour'); },\n            get hours() { return $t('hours'); },\n            get day() { return $t('day'); },\n            get days() { return $t('days'); },\n        };\n\n        resultUnit = i18nTime[`${resultUnit}${resultTime !== 1 ? 's' : ''}` as (keyof typeof i18nTime)];\n        return `${resultTime} ${resultUnit}`;\n    }\n}\n\nconst TIMER_REM_FACTOR = 8; // size of 1rem\nconst TIMER_BASE_SIZE = 3.25 * TIMER_REM_FACTOR;\nconst TIMER_BASE_RADIUS = TIMER_REM_FACTOR;\nconst TIMER_RADIUS_GROWTH_FACTOR = 1.5;\n\nexport enum TimerEvents {\n    END = 'end',\n}\n\nexport enum TimerThemes {\n    NORMAL = 'normal',\n    INVERSE = 'inverse',\n    WHITE = 'white',\n}\n\nexport default defineComponent({\n    name: 'Timer',\n    // extends: I18nMixin,\n    props: {\n        startTime: Number,\n        endTime: Number,\n        alwaysShowTime: {\n            type: Boolean,\n            default: true,\n        },\n        theme: {\n            type: String,\n            default: 'normal',\n            validator: (value: any) => Object.values(TimerThemes).includes(value),\n        },\n        strokeWidth: {\n            type: Number,\n            default: 2,\n        },\n        tooltipProps: Object,\n        maxUnit: {\n            type: String,\n            required: false,\n            validator: (value: any) => [undefined, 'second', 'minute', 'hour', 'day'].includes(value),\n        },\n    },\n    setup(props, context) {\n        const root$ = ref<typeof Tooltip | null>(null);\n\n        const timeOffset = ref(0);\n        const sampledTime = ref(0);\n        const detailsShown = ref(false);\n        // While the radius r of the circle and the values stroke-dasharray, stroke-dashoffset and stroke-width that depend\n        // on the radius can be transitioned via css, the behavior on value update during an ongoing transition is not\n        // consistent (e.g. time update while animating on user hover or quick hover and unhover). Therefore animate via JS.\n        const radius: Tweenable = new Tweenable(detailsShown.value || props.alwaysShowTime\n            ? TIMER_BASE_RADIUS * TIMER_RADIUS_GROWTH_FACTOR\n            : TIMER_BASE_RADIUS);\n        const fullCircleLength = ref(2 * Math.PI * radius.currentValue);\n        const timeoutId = ref<number | null>(null);\n        const updateTimeoutId = ref<number | null>(null);\n        const requestAnimationFrameId = ref<number | null>(null);\n        const size = ref(TIMER_BASE_SIZE);\n\n        function synchronize(referenceTime: number) {\n            timeOffset.value = referenceTime - Date.now();\n        }\n\n        context.expose({ synchronize });\n\n        onMounted(() => {\n            requestAnimationFrame(() => size.value = root$.value!.offsetWidth); // in rAF to avoid forced reflow\n            // this.onResize = this.onResize.bind(this); // TODO: do we still need this?\n            window.addEventListener('resize', onResize);\n        });\n\n        onUnmounted(() => {\n            if (timeoutId.value) clearTimeout(timeoutId.value);\n            if (updateTimeoutId.value) clearTimeout(updateTimeoutId.value);\n            if (requestAnimationFrameId.value) cancelAnimationFrame(requestAnimationFrameId.value);\n            window.removeEventListener('resize', onResize);\n        });\n\n        const totalTimeRef = computed(() => {\n            if (props.startTime === undefined || props.endTime === undefined) {\n                return 0;\n            } else {\n                return Math.max(0, props.endTime - props.startTime);\n            }\n        });\n\n        const timeLeftRef = computed(() => {\n            if (props.startTime === undefined || props.endTime === undefined) {\n                return 0;\n            } else {\n                return Math.max(0, Math.min(totalTimeRef.value, props.endTime - sampledTime.value));\n            }\n        });\n\n        const progress = computed(() => {\n            if (props.startTime === undefined || props.endTime === undefined || totalTimeRef.value === 0) {\n                return 0;\n            } else {\n                return 1 - timeLeftRef.value / totalTimeRef.value;\n            }\n        });\n\n        const timeCircleInfo = computed<CircleInfo>(() => {\n            // Have a max length to make it more recognizable that this is a timer by never rendering a full circle.\n            // The rounded stroke ending rendered with radius strokeWidth/2 does not count towards the stroke length,\n            // therefore to get the desired gap of 1.5 strokeWidths, we use 2.5 strokeWidths.\n            const maxLength = fullCircleLength.value - 2.5 * props.strokeWidth;\n            const length = Math.min(maxLength, (1 - progress.value) * fullCircleLength.value);\n            const lengthWithLineCaps = length + props.strokeWidth; // add line caps with strokeWidth/2 radius\n            const gap = fullCircleLength.value - length;\n            // The path grows clockwise starting on the right side. Offset by 90 degrees and gap to let path start with gap\n            // and end on top.\n            const offset = fullCircleLength.value / 4 - gap;\n            return { length, lengthWithLineCaps, gap, offset, strokeWidth: props.strokeWidth };\n        });\n\n        const fillerCircleInfo = computed<CircleInfo>(() => {\n            // Filler circle should be rendered in the gap left by the time circle with a margin of strokeWidth. If there\n            // is not enough space, compensate by reducing the filler circle stroke width.\n            const availableSpace = fullCircleLength.value - timeCircleInfo.value.lengthWithLineCaps - 2 * props.strokeWidth;\n            const lengthWithLineCaps = Math.max(0, availableSpace);\n            const strokeWidth = Math.min(props.strokeWidth, lengthWithLineCaps);\n            const length = Math.max(0, lengthWithLineCaps - strokeWidth); // subtract rounded line caps\n            const gap = fullCircleLength.value - length;\n            const offset = fullCircleLength.value / 4 // rotate by 90 degrees\n                - props.strokeWidth / 2 // skip rounded line cap of time circle\n                - props.strokeWidth // margin\n                - strokeWidth / 2; // account for our own line cap\n            return { length, lengthWithLineCaps, gap, offset, strokeWidth };\n        });\n\n        function calculateUpdateInterval(): number {\n            // Not a getter / computed prop to avoid unnecessary updates when not needed.\n            const scaleFactor = size.value / TIMER_BASE_SIZE;\n            const circleLengthPixels = fullCircleLength.value * scaleFactor;\n            const steps = circleLengthPixels * 3; // update every .33 pixel change for smooth transitions\n            const minInterval = 1000 / 60; // up to 60 fps\n            // Constrain interval such that we don't skip time steps in the countdown for the respective time unit.\n            const timeLeft = timeLeftRef.value;\n            const totalTime = totalTimeRef.value;\n            const updatesPerTimeStep = 2; // multiple updates per time step to avoid skipping a step by a delayed interval\n            let timeStep = 1000; // starting with seconds\n            let maxInterval = timeStep / updatesPerTimeStep;\n            for (const { factor } of TIME_STEPS) {\n                const nextTimeStep = timeStep * factor;\n                const nextMaxInterval = nextTimeStep / updatesPerTimeStep;\n                const nextInterval = Math.min(nextMaxInterval, Math.max(minInterval, totalTime / steps));\n                if ((timeLeft - nextInterval) / nextTimeStep < 1) {\n                    // If the time left after nextInterval can't be expressed in nextTimeStep as a value >=1, stop. We check\n                    // for the time after the next interval to avoid jumping for example from 70s (displayed as 1 minute)\n                    // directly to 50s if the interval is 20s. Note that the behavior here resembles the one in\n                    // toSimplifiedTime.\n                    if (timeLeft / nextTimeStep > 1) {\n                        // If the value before the interval is still >1 in the next time unit still allow a larger jump than\n                        // at the smaller time unit but set the maxInterval such that we jump no further than where the\n                        // switch to the smaller unit happens, for example jump from 70s to 60s if the interval is 20s.\n                        maxInterval = timeLeft - nextTimeStep;\n                    }\n                    break;\n                }\n                timeStep = nextTimeStep;\n                maxInterval = nextMaxInterval;\n            }\n\n            return Math.min(maxInterval, Math.max(minInterval, totalTimeRef.value / steps));\n        }\n\n        watch(detailsShown, setRadius, { immediate: true });\n        watch(() => props.alwaysShowTime, setRadius);\n\n        function setRadius() {\n            radius.tweenTo(detailsShown.value || props.alwaysShowTime\n                ? TIMER_RADIUS_GROWTH_FACTOR * TIMER_BASE_RADIUS\n                : TIMER_BASE_RADIUS, 300);\n            rerender();\n        }\n\n        watch(() => props.startTime, setTimer, { immediate: true });\n        watch(() => props.endTime, setTimer);\n        watch(timeOffset, setTimer);\n\n        function setTimer() {\n            sampledTime.value = Date.now() + timeOffset.value;\n            if (timeoutId.value) clearTimeout(timeoutId.value);\n            if (props.startTime && props.endTime) {\n                timeoutId.value = window.setTimeout(() => context.emit(TimerEvents.END, props.endTime),\n                    props.endTime - sampledTime.value);\n                rerender();\n            }\n        }\n\n        function rerender() {\n            sampledTime.value = Date.now() + timeOffset.value;\n            fullCircleLength.value = 2 * Math.PI * radius.currentValue;\n\n            if (timeLeftRef.value === 0 && radius.finished) return;\n\n            if (updateTimeoutId.value) clearTimeout(updateTimeoutId.value);\n            if (requestAnimationFrameId.value) cancelAnimationFrame(requestAnimationFrameId.value);\n\n            if (!radius.finished) {\n                // animate radius with high frame rate\n                requestAnimationFrameId.value = requestAnimationFrame(() => rerender());\n            } else {\n                // update with low frame rate\n                updateTimeoutId.value = window.setTimeout(() => rerender(), calculateUpdateInterval());\n            }\n        }\n\n        function onResize() {\n            if (root$.value) size.value = root$.value.offsetWidth;\n        }\n\n        return {\n            toSimplifiedTime,\n\n            TooltipThemes,\n            TimerThemes,\n\n            root$,\n\n            detailsShown,\n            radius,\n\n            timeLeftRef,\n            progress,\n            timeCircleInfo,\n            fillerCircleInfo,\n        };\n    },\n    components: { Tooltip, I18n },\n})\n</script>\n\n<style scoped>\n    .timer {\n        width: 3.25rem;\n        position: relative;\n    }\n\n    /* for setting height automatically depending on width */\n    .timer::before {\n        content: '';\n        padding-top: 100%;\n        display: block;\n    }\n\n    .tooltip:deep(.trigger),\n    svg {\n        display: block;\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n    }\n\n    svg {\n        fill: none;\n        stroke-linecap: round;\n    }\n\n    circle {\n        stroke: var(--nimiq-blue);\n        transition: stroke .3s var(--nimiq-ease), opacity .3s var(--nimiq-ease);\n    }\n\n    .inverse-theme circle,\n    .white-theme circle {\n        stroke: white;\n    }\n\n    .filler-circle {\n        opacity: .2;\n    }\n\n    .time-circle {\n        opacity: .3;\n    }\n\n    .time-shown .time-circle {\n        stroke: var(--nimiq-light-blue);\n        opacity: 1;\n    }\n\n    .inverse-theme.time-shown:not(.little-time-left) .time-circle {\n        stroke: var(--nimiq-light-blue-on-dark, var(--nimiq-light-blue));\n    }\n\n    .white-theme.time-shown:not(.little-time-left) .time-circle {\n        stroke: rgba(255, 255, 255, 0.4);\n    }\n\n    /* .inverse-theme.time-shown .filler-circle,\n    .white-theme.time-shown .filler-circle {\n        opacity: 0;\n    } */\n\n    .little-time-left .time-circle {\n        stroke: var(--nimiq-orange);\n        opacity: 1;\n    }\n\n    .info-exclamation-icon {\n        fill: var(--nimiq-blue);\n        opacity: .4;\n        transform-origin: center;\n        transition: fill .3s var(--nimiq-ease), opacity .3s var(--nimiq-ease), transform .3s var(--nimiq-ease);\n    }\n\n    .inverse-theme .info-exclamation-icon,\n    .white-theme .info-exclamation-icon {\n        fill: white;\n    }\n\n    .little-time-left .info-exclamation-icon {\n        fill: var(--nimiq-orange);\n        opacity: 1;\n        transform: rotate(180deg); /* turn info icon into an exclamation mark */\n    }\n\n    .countdown {\n        font-size: 12px; /* relative to svg viewBox */\n        font-weight: bold;\n        text-anchor: middle;\n        dominant-baseline: central;\n        fill: var(--nimiq-light-blue);\n        transition: fill .3s var(--nimiq-ease);\n    }\n\n    .inverse-theme .countdown {\n        fill: var(--nimiq-light-blue-on-dark, var(--nimiq-light-blue));\n    }\n\n    .white-theme .countdown {\n        fill: rgba(255, 255, 255, 0.6);\n    }\n\n    .little-time-left .countdown {\n        fill: var(--nimiq-orange);\n    }\n\n    .transition-fade-enter-active,\n    .transition-fade-leave-active {\n        transition: opacity .3s var(--nimiq-ease);\n    }\n\n    .transition-fade-enter,\n    .transition-fade-leave-to {\n        opacity: 0 !important;\n    }\n</style>\n"],"names":["TIME_STEPS","toSimplifiedTime","millis","includeUnit","maxUnit","resultTime","resultUnit","unit","factor","$t","loadI18n","TIMER_REM_FACTOR","TIMER_BASE_SIZE","TIMER_BASE_RADIUS","TIMER_RADIUS_GROWTH_FACTOR","TimerThemes","_sfc_main","defineComponent","value","props","context","root$","ref","timeOffset","sampledTime","detailsShown","radius","Tweenable","fullCircleLength","timeoutId","updateTimeoutId","requestAnimationFrameId","size","synchronize","referenceTime","onMounted","onResize","onUnmounted","totalTimeRef","computed","timeLeftRef","progress","timeCircleInfo","maxLength","length","lengthWithLineCaps","gap","offset","fillerCircleInfo","availableSpace","strokeWidth","calculateUpdateInterval","scaleFactor","steps","minInterval","timeLeft","totalTime","updatesPerTimeStep","timeStep","maxInterval","nextTimeStep","nextMaxInterval","nextInterval","watch","setRadius","rerender","setTimer","TooltipThemes","Tooltip","I18n"],"mappings":"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"}