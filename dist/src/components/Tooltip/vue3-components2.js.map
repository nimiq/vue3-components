{"version":3,"file":"vue3-components2.js","sources":["../../../../src/components/Tooltip/Tooltip.vue"],"sourcesContent":["<template>\n    <span class=\"tooltip\" ref=\"root$\"\n        :class=\"[verticalPosition, {\n            shown: isShown,\n            'transition-position': transitionPosition,\n            'inverse-theme': theme === TooltipThemes.INVERSE,\n        }]\"\n        @mouseenter=\"mouseOver(true)\"\n        @mouseleave=\"mouseOver(false)\"\n    >\n        <a href=\"javascript:void(0);\"\n            ref=\"tooltipTrigger$\"\n            @focus.stop=\"show()\"\n            @blur.stop=\"hide()\"\n            @click=\"onClick()\"\n            :tabindex=\"disabled || noFocus ? -1 : 0\"\n            class=\"trigger\"\n        >\n            <slot v-if=\"!$slots.icon\" name=\"trigger\">\n                <AlertTriangleIcon class=\"nq-orange\" />\n            </slot>\n            <!-- Note: usage of the `icon` slot is deprecated. Use `trigger` instead. -->\n            <slot v-if=\"$slots.icon && !$slots.trigger\" name=\"icon\"></slot>\n        </a>\n        <transition name=\"transition-fade\">\n            <div ref=\"tooltipBox$\"\n                v-if=\"isShown\"\n                class=\"tooltip-box\"\n                :style=\"tooltipBoxStyles\">\n                <slot></slot>\n            </div>\n        </transition>\n    </span>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, nextTick, onMounted, onUnmounted, ref, watch } from 'vue';\nimport { StyleValue } from '@vue/runtime-dom';\nimport { AlertTriangleIcon } from '../../icons/Icons';\n\nexport enum TooltipVerticalPosition {\n    TOP = 'top',\n    BOTTOM = 'bottom',\n}\n\nexport enum TooltipHorizontalPosition {\n    LEFT = 'left',\n    RIGHT = 'right',\n}\n\nexport enum TooltipThemes {\n    NORMAL = 'normal',\n    INVERSE = 'inverse',\n}\n\nexport enum TooltipEvents {\n    SHOW = 'show',\n    HIDE = 'hide',\n    CLICK = 'click',\n}\n\nexport default defineComponent({\n    name: 'Tooltip',\n    emits: Object.values(TooltipEvents),\n    props: {\n        /**\n        * Container within which the tooltip should be positioned if possible.\n        */\n        container: HTMLElement,\n        disabled: {\n            type: Boolean,\n            default: false,\n        },\n        noFocus: {\n            type: Boolean,\n            default: false,\n        },\n        /**\n        * Preferred tooltip position as \"[vertical] [horizontal]\" or \"[vertical]\".\n        */\n        preferredPosition: {\n            type: String,\n            default: 'top right',\n            validator: (value: unknown) => {\n                if (typeof value !== 'string') return false;\n                const [vertical, horizontal] = value.split(' ');\n                return Object.values(TooltipVerticalPosition).includes(vertical as TooltipVerticalPosition)\n                    && (!horizontal || Object.values(TooltipHorizontalPosition)\n                        .includes(horizontal as TooltipHorizontalPosition));\n            },\n        },\n        /**\n        * Margin to maintain to container. If no container is set, this prop has no effect. For omitted values, the\n        * container's padding is used as margin.\n        */\n        margin: {\n            type: Object as () => Partial<Record<TooltipVerticalPosition | TooltipHorizontalPosition, number>>,\n            validator: (value: any) => typeof value === 'object'\n                && Object.entries(value).every(([position, margin]) => typeof margin === 'number'\n                    && (Object.values(TooltipVerticalPosition).includes(position as TooltipVerticalPosition)\n                        || Object.values(TooltipHorizontalPosition).includes(position as TooltipHorizontalPosition))),\n        },\n        /**\n        * Sets the tooltip's width to the container's width minus margin. If no container is set, this prop has no effect.\n        */\n        autoWidth: {\n            type: Boolean,\n            default: false,\n        },\n        theme: {\n            type: String as () => TooltipThemes,\n            default: 'normal' as TooltipThemes.NORMAL,\n            validator: (value: any) => Object.values(TooltipThemes).includes(value),\n        },\n        /**\n        * Styles to apply on the tooltip box without the need to use deep css selectors.\n        */\n        styles: Object as () => Partial<CSSStyleDeclaration>,\n    },\n    setup(props, context) {\n        const tooltipTrigger$ = ref<HTMLAnchorElement | null>(null);\n        const tooltipBox$ = ref<HTMLDivElement | null>(null);\n        const root$ = ref<HTMLElement | null>(null);\n\n        const verticalPosition = ref<TooltipVerticalPosition | null>(null);\n        const tooltipToggled = ref(false);\n        const transitionPosition = ref(false); // do not transition on show but on position updates while shown\n        const mousedOver = ref(false);\n        const mouseOverTimeout = ref<number | null>(null);\n        const lastToggle = ref(-1);\n\n        const height = ref(0);\n        const width = ref(0);\n        const maxWidth = ref(0);\n        const left = ref(0);\n        const top = ref(0);\n\n        const isShown = computed(() => {\n            return (tooltipToggled.value || mousedOver.value) && !props.disabled;\n        });\n\n        const tooltipBoxStyles = computed(() => {\n            // note that we let the browser calculate height automatically\n            return {\n                ...props.styles,\n                top: top.value + 'px',\n                left: left.value + 'px',\n                width: props.container && props.autoWidth ? width.value + 'px' : (props.styles || {}).width,\n                maxWidth: props.container ? maxWidth.value + 'px' : (props.styles || {}).maxWidth,\n            } as StyleValue;\n        });\n\n        onMounted(() => {\n            if ('icon' in context.slots) {\n                console.warn('Tooltip: Slot `icon` is deprecated and support will be removed in the future.'\n                    + ' Use slot `trigger` instead.');\n            }\n            // Manually trigger an update instead of using immediate watchers to avoid unnecessary initial double updates\n            if (props.container) setContainer(props.container);\n        });\n\n        onUnmounted(() => {\n            if (props.container) {\n                props.container.removeEventListener('scroll', updatePosition);\n            }\n        });\n\n        function show() {\n            tooltipToggled.value = true;\n        }\n\n        function hide(force: boolean = false) {\n            tooltipToggled.value = false;\n            if (tooltipTrigger$.value) tooltipTrigger$.value.blur();\n            if (!force) return;\n            mousedOver.value = false;\n        }\n\n        function toggle(force: boolean = false) {\n            if (tooltipToggled.value || mousedOver.value) {\n                hide(force);\n            } else {\n                show();\n            }\n        }\n\n        watch(isShown, update);\n        async function update(newWatcherValue?: boolean) {\n            // updates dimensions and repositions tooltip\n            if (!isShown.value) {\n                transitionPosition.value = false; // when shown next time, render immediately at correct position\n                if (newWatcherValue === false) {\n                    lastToggle.value = Date.now();\n                    context.emit(TooltipEvents.HIDE);\n                }\n                return; // no need to update as tooltip not visible\n            } else if (newWatcherValue === true) {\n                lastToggle.value = Date.now();\n                context.emit(TooltipEvents.SHOW);\n            }\n\n            if (props.container) {\n                await new Promise((resolve) => requestAnimationFrame(() => {\n                    if (!props.container) return;\n\n                    // avoid potential forced layouting / reflow by taking measurements within a requestAnimationFrame\n                    // (see https://gist.github.com/paulirish/5d52fb081b3570c81e3a#appendix)\n                    const leftMargin = getMargin(TooltipHorizontalPosition.LEFT) || 0;\n                    const rightMargin = getMargin(TooltipHorizontalPosition.RIGHT) || 0;\n\n                    maxWidth.value = props.container.offsetWidth - leftMargin - rightMargin;\n                    if (props.autoWidth) width.value = maxWidth.value;\n                    resolve(null);\n                }));\n            }\n\n            // make sure that tooltipBox is created, then update measurements\n            await nextTick();\n            if (!isShown.value || !tooltipBox$.value) return; // not visible anymore?\n            // here we need the quick reflow to avoid that the visible tooltip gets rendered at the wrong position,\n            // potentially causing scroll bars\n            height.value = tooltipBox$.value.offsetHeight;\n            width.value = tooltipBox$.value.offsetWidth;\n\n            updatePosition();\n\n            // wait for updated position to be effective and rendered, then enable transitions\n            await nextTick();\n            await new Promise((resolve) => requestAnimationFrame(resolve));\n            transitionPosition.value = true;\n        }\n\n        watch(() => props.preferredPosition, updatePosition);\n        function updatePosition() {\n            if (!isShown.value || !tooltipTrigger$.value) return;\n            // Note that in his method we do not need to use requestAnimationFrame to avoid reflows, as the method is\n            // already called as a scroll event listener or manually in update after a reflow.\n            // tslint:disable-next-line:prefer-const\n            let [preferredVerticalPosition, preferredHorizontalPosition] = props.preferredPosition.split(' ');\n            preferredHorizontalPosition = preferredHorizontalPosition || TooltipHorizontalPosition.RIGHT;\n            left.value = preferredHorizontalPosition === TooltipHorizontalPosition.RIGHT\n                ? Math.round(tooltipTrigger$.value.offsetWidth / 2 - 25) // offset by 25px according to designs\n                : Math.round(tooltipTrigger$.value.offsetWidth / 2 - width.value + 25);\n\n            if (props.container) {\n                // position tooltip such that it best fits container element\n                const triggerBoundingRect = tooltipTrigger$.value.getBoundingClientRect();\n                const containerBoundingRect = props.container.getBoundingClientRect();\n                const topMargin = getMargin(TooltipVerticalPosition.TOP) || 0;\n                const bottomMargin = getMargin(TooltipVerticalPosition.BOTTOM) || 0;\n                const spaceNeeded = height.value + 16; // 16 for arrow, assuming same height on mobile for simplicity\n                const fitsTop = triggerBoundingRect.top - containerBoundingRect.top - topMargin >= spaceNeeded;\n                const fitsBottom = containerBoundingRect.bottom - triggerBoundingRect.bottom - bottomMargin >= spaceNeeded;\n                if ((preferredVerticalPosition === TooltipVerticalPosition.TOP && (fitsTop || !fitsBottom))\n                    || (preferredVerticalPosition === TooltipVerticalPosition.BOTTOM) && (fitsTop && !fitsBottom)) {\n                    verticalPosition.value = TooltipVerticalPosition.TOP;\n                } else {\n                    verticalPosition.value = TooltipVerticalPosition.BOTTOM;\n                }\n\n                // constrain horizontal position\n                const leftMargin = getMargin(TooltipHorizontalPosition.LEFT) || 0;\n                const rightMargin = getMargin(TooltipHorizontalPosition.RIGHT) || 0;\n                // left and right bound of container, expressed in trigger's coordinate system\n                const leftBound = containerBoundingRect.left + leftMargin - triggerBoundingRect.left;\n                const rightBound = containerBoundingRect.right - rightMargin - triggerBoundingRect.left;\n                left.value = Math.max(\n                    leftBound,\n                    Math.min(\n                        rightBound - width.value,\n                        left.value,\n                    ),\n                );\n            } else {\n                verticalPosition.value = preferredVerticalPosition as TooltipVerticalPosition;\n            }\n\n            top.value = verticalPosition.value === TooltipVerticalPosition.BOTTOM\n                ? tooltipTrigger$.value.offsetHeight\n                : -height.value;\n        }\n\n        watch(() => props.container, setContainer);\n        async function setContainer(newContainer?: HTMLElement, oldContainer?: HTMLElement) {\n            if (oldContainer) {\n                oldContainer.removeEventListener('scroll', updatePosition);\n            }\n\n            if (newContainer) {\n                // In case the container is scrollable add a listener\n                await new Promise((resolve) => requestAnimationFrame(()  => {\n                    if (newContainer.scrollHeight !== newContainer.offsetHeight) {\n                        newContainer.addEventListener('scroll', updatePosition);\n                    }\n                    resolve(null);\n                }));\n            }\n\n            await update();\n        }\n\n        function getMargin(position: TooltipVerticalPosition | TooltipHorizontalPosition) {\n            if (props.margin && props.margin[position] !== undefined) return props.margin[position];\n\n            const containerEl = props.container || null;\n            if (!containerEl) return 0;\n\n            if ((position === TooltipVerticalPosition.TOP || position === TooltipVerticalPosition.BOTTOM)\n                && containerEl.scrollHeight !== containerEl.offsetHeight) {\n                // If container is scrollable, the padding scrolls with the content. Therefore we consider the whole\n                // offsetHeight as valid area for the tooltip and return a margin of 0.\n                return 0;\n            }\n            return parseInt(window.getComputedStyle(containerEl, null).getPropertyValue(`padding-${position}`), 10);\n        }\n\n        function mouseOver(mouseOverTooltip: boolean) {\n            if (!mouseOverTooltip) { // mouseleave\n                mouseOverTimeout.value = window.setTimeout(\n                    () => mousedOver.value = false,\n                    100,\n                );\n            } else { // mouseenter\n                if (mouseOverTimeout.value) window.clearTimeout(mouseOverTimeout.value);\n                mousedOver.value = true;\n            }\n        }\n\n        function onClick() {\n            if (Date.now() - lastToggle.value < 200) return; // just toggled by mouseover or focus\n            toggle(/* force */ true);\n            context.emit(TooltipEvents.CLICK);\n        }\n\n        context.expose({ show, hide, toggle, update });\n\n        return {\n            TooltipThemes,\n\n            tooltipTrigger$,\n            tooltipBox$,\n            root$,\n\n            verticalPosition,\n            transitionPosition,\n\n            isShown,\n            tooltipBoxStyles,\n\n            show,\n            hide,\n            mouseOver,\n            onClick,\n        };\n    },\n    components: { AlertTriangleIcon }\n})\n</script>\n\n<style scoped>\n    .tooltip {\n        display: inline-block;\n        position: relative;\n        line-height: 1;\n    }\n\n    .trigger {\n        position: relative;\n        display: inline-block;\n        vertical-align: bottom;\n        text-decoration: none;\n        outline: none;\n        cursor: default;\n        color: inherit;\n    }\n\n    .trigger:deep(svg:first-child:last-child),\n    .trigger:deep(img:first-child:last-child) {\n        display: block;\n    }\n\n    .trigger::after {\n        opacity: 0;\n        content: '';\n        display: block;\n        position: absolute;\n        width: 2.25rem;\n        height: 2rem;\n        left: calc(50% - 1.125rem);\n        mask-image: url('data:image/svg+xml,<svg viewBox=\"0 0 18 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9 7.12c-.47 0-.93.2-1.23.64L3.2 14.29A4 4 0 0 1 0 16h18a4 4 0 0 1-3.2-1.7l-4.57-6.54c-.3-.43-.76-.64-1.23-.64z\" fill=\"white\"/></svg>');\n        transition: opacity .3s var(--nimiq-ease), .3s visibility;\n        transition-delay: 16ms; /* delay one animation frame for better sync with tooltipBox */\n        visibility: hidden;\n        z-index: 1000; /* move above tooltip-box's box-shadow */\n    }\n\n    .transition-position .trigger::after {\n        transition: top .2s var(--nimiq-ease), left .2s var(--nimiq-ease), transform .2s var(--nimiq-ease),\n            opacity .3s var(--nimiq-ease), .3s visibility;\n    }\n\n    .top .trigger::after {\n        top: -2rem;\n        background: #250636; /* a color of the nimiq-blue-bg gradient in the lower area */\n        transform: scaleY(-1);\n    }\n\n    .bottom .trigger::after {\n        top: 100%;\n        background: #201e45; /* a color of the nimiq-blue-bg gradient in the upper area */\n    }\n\n    .inverse-theme .trigger::after {\n        background: white;\n    }\n\n    .shown .trigger::after {\n        opacity: 1;\n        visibility: visible;\n    }\n\n    .tooltip-box {\n        position: absolute;\n        color: white;\n        background: var(--nimiq-blue-bg);\n        padding: 1.5rem;\n        border-radius: .5rem;\n        font-size: 1.75rem;\n        line-height: 1.5;\n        font-weight: 600;\n        transition: opacity .3s var(--nimiq-ease);\n        box-shadow: 0 1.125rem 2.275rem rgba(0, 0, 0, 0.11);\n        z-index: 999;\n    }\n\n    .inverse-theme .tooltip-box {\n        color: var(--nimiq-blue);\n        background: white;\n    }\n\n    .transition-position .tooltip-box {\n        transition: opacity .3s var(--nimiq-ease), transform .2s var(--nimiq-ease), top .2s var(--nimiq-ease);\n    }\n\n    .tooltip-box.transition-fade-enter-from,\n    .tooltip-box.transition-fade-leave-to {\n        opacity: 0;\n    }\n\n    .top .tooltip-box {\n        transform: translateY(-2rem);\n    }\n\n    .bottom .tooltip-box {\n        transform: translateY(2rem);\n    }\n</style>\n"],"names":["TooltipVerticalPosition","TooltipHorizontalPosition","TooltipThemes","TooltipEvents","_sfc_main","defineComponent","value","vertical","horizontal","position","margin","props","context","tooltipTrigger$","ref","tooltipBox$","root$","verticalPosition","tooltipToggled","transitionPosition","mousedOver","mouseOverTimeout","lastToggle","height","width","maxWidth","left","top","isShown","computed","tooltipBoxStyles","onMounted","setContainer","onUnmounted","updatePosition","show","hide","force","toggle","watch","update","newWatcherValue","resolve","leftMargin","getMargin","rightMargin","nextTick","preferredVerticalPosition","preferredHorizontalPosition","triggerBoundingRect","containerBoundingRect","topMargin","bottomMargin","spaceNeeded","fitsTop","fitsBottom","leftBound","rightBound","newContainer","oldContainer","containerEl","mouseOver","mouseOverTooltip","onClick","AlertTriangleIcon"],"mappings":"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"}