{"version":3,"file":"vue3-components.js","sources":["../../../../src/components/Tooltip/Tooltip.vue"],"sourcesContent":["<template>\n    <span class=\"tooltip\" ref=\"root$\"\n        :class=\"[verticalPosition, {\n            shown: isShown,\n            'transition-position': transitionPosition,\n            'inverse-theme': theme === TooltipThemes.INVERSE,\n        }]\"\n        @mouseenter=\"mouseOver(true)\"\n        @mouseleave=\"mouseOver(false)\"\n    >\n        <a href=\"javascript:void(0);\"\n            ref=\"tooltipTrigger$\"\n            @focus.stop=\"show()\"\n            @blur.stop=\"hide()\"\n            @click=\"onClick()\"\n            :tabindex=\"disabled || noFocus ? -1 : 0\"\n            class=\"trigger\"\n        >\n            <slot v-if=\"!$slots.icon\" name=\"trigger\">\n                <AlertTriangleIcon class=\"nq-orange\" />\n            </slot>\n            <!-- Note: usage of the `icon` slot is deprecated. Use `trigger` instead. -->\n            <slot v-if=\"$slots.icon && !$slots.trigger\" name=\"icon\"></slot>\n        </a>\n        <transition name=\"transition-fade\">\n            <div ref=\"tooltipBox$\"\n                v-if=\"isShown\"\n                class=\"tooltip-box\"\n                :style=\"tooltipBoxStyles\">\n                <slot></slot>\n            </div>\n        </transition>\n    </span>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, nextTick, onMounted, onUnmounted, ref, watch } from 'vue';\nimport { StyleValue } from '@vue/runtime-dom';\nimport { AlertTriangleIcon } from '../../icons/Icons';\n\nexport enum TooltipVerticalPosition {\n    TOP = 'top',\n    BOTTOM = 'bottom',\n}\n\nexport enum TooltipHorizontalPosition {\n    LEFT = 'left',\n    RIGHT = 'right',\n}\n\nexport enum TooltipThemes {\n    NORMAL = 'normal',\n    INVERSE = 'inverse',\n}\n\nexport default defineComponent({\n    name: 'Tooltip',\n    props: {\n        /**\n        * Container within which the tooltip should be positioned if possible.\n        */\n        container: HTMLElement,\n        disabled: Boolean,\n        noFocus: Boolean,\n        /**\n        * Preferred tooltip position as \"[vertical] [horizontal]\" or \"[vertical]\".\n        */\n        preferredPosition: {\n            type: String,\n            default: 'top right',\n            validator: (value: unknown) => {\n                if (typeof value !== 'string') return false;\n                const [vertical, horizontal] = value.split(' ');\n                return Object.values(TooltipVerticalPosition).includes(vertical as TooltipVerticalPosition)\n                    && (!horizontal || Object.values(TooltipHorizontalPosition)\n                        .includes(horizontal as TooltipHorizontalPosition));\n            },\n        },\n        /**\n        * Margin to maintain to container. If no container is set, this prop has no effect. For omitted values, the\n        * container's padding is used as margin.\n        */\n        margin: {\n            type: Object as () => Partial<Record<TooltipVerticalPosition | TooltipHorizontalPosition, number>>,\n            validator: (value: any) => typeof value === 'object'\n                && Object.entries(value).every(([position, margin]) => typeof margin === 'number'\n                    && (Object.values(TooltipVerticalPosition).includes(position as TooltipVerticalPosition)\n                        || Object.values(TooltipHorizontalPosition).includes(position as TooltipHorizontalPosition))),\n        },\n        /**\n        * Sets the tooltip's width to the container's width minus margin. If no container is set, this prop has no effect.\n        */\n        autoWidth: {\n            type: Boolean,\n            default: false,\n        },\n        theme: {\n            type: String as () => TooltipThemes,\n            default: 'normal' as TooltipThemes.NORMAL,\n            validator: (value: any) => Object.values(TooltipThemes).includes(value),\n        },\n        /**\n        * Styles to apply on the tooltip box without the need to use deep css selectors.\n        */\n        styles: Object as () => Partial<CSSStyleDeclaration>,\n    },\n    setup(props, context) {\n        const tooltipTrigger$ = ref<HTMLAnchorElement | null>(null);\n        const tooltipBox$ = ref<HTMLDivElement | null>(null);\n        const root$ = ref<HTMLElement | null>(null);\n\n        const verticalPosition = ref<TooltipVerticalPosition | null>(null);\n        const tooltipToggled = ref(false);\n        const transitionPosition = ref(false); // do not transition on show but on position updates while shown\n        const mousedOver = ref(false);\n        const mouseOverTimeout = ref<number | null>(null);\n        const lastToggle = ref(-1);\n\n        const height = ref(0);\n        const width = ref(0);\n        const maxWidth = ref(0);\n        const left = ref(0);\n        const top = ref(0);\n\n        const isShown = computed(() => {\n            return (tooltipToggled.value || mousedOver.value) && !props.disabled;\n        });\n\n        const tooltipBoxStyles = computed(() => {\n            // note that we let the browser calculate height automatically\n            return {\n                ...props.styles,\n                top: top.value + 'px',\n                left: left.value + 'px',\n                width: props.container && props.autoWidth ? width.value + 'px' : (props.styles || {}).width,\n                maxWidth: props.container ? maxWidth.value + 'px' : (props.styles || {}).maxWidth,\n            } as StyleValue;\n        });\n\n        onMounted(() => {\n            if ('icon' in context.slots) {\n                console.warn('Tooltip: Slot `icon` is deprecated and support will be removed in the future.'\n                    + ' Use slot `trigger` instead.');\n            }\n            // Manually trigger an update instead of using immediate watchers to avoid unnecessary initial double updates\n            if (props.container) setContainer(props.container);\n        });\n\n        onUnmounted(() => {\n            if (props.container) {\n                props.container.removeEventListener('scroll', updatePosition);\n            }\n        });\n\n        function show() {\n            tooltipToggled.value = true;\n        }\n\n        function hide(force: boolean = false) {\n            tooltipToggled.value = false;\n            if (tooltipTrigger$.value) tooltipTrigger$.value.blur();\n            if (!force) return;\n            mousedOver.value = false;\n        }\n\n        function toggle(force: boolean = false) {\n            if (tooltipToggled.value || mousedOver.value) {\n                hide(force);\n            } else {\n                show();\n            }\n        }\n\n        watch(isShown, update);\n        async function update(newWatcherValue?: boolean) {\n            // updates dimensions and repositions tooltip\n            if (!isShown.value) {\n                transitionPosition.value = false; // when shown next time, render immediately at correct position\n                if (newWatcherValue === false) {\n                    lastToggle.value = Date.now();\n                    context.emit('hide');\n                }\n                return; // no need to update as tooltip not visible\n            } else if (newWatcherValue === true) {\n                lastToggle.value = Date.now();\n                context.emit('show');\n            }\n\n            if (props.container) {\n                await new Promise((resolve) => requestAnimationFrame(() => {\n                    if (!props.container) return;\n\n                    // avoid potential forced layouting / reflow by taking measurements within a requestAnimationFrame\n                    // (see https://gist.github.com/paulirish/5d52fb081b3570c81e3a#appendix)\n                    const leftMargin = getMargin(TooltipHorizontalPosition.LEFT) || 0;\n                    const rightMargin = getMargin(TooltipHorizontalPosition.RIGHT) || 0;\n\n                    maxWidth.value = props.container.offsetWidth - leftMargin - rightMargin;\n                    if (props.autoWidth) width.value = maxWidth.value;\n                    resolve(null);\n                }));\n            }\n\n            // make sure that tooltipBox is created, then update measurements\n            await nextTick();\n            if (!isShown.value || !tooltipBox$.value) return; // not visible anymore?\n            // here we need the quick reflow to avoid that the visible tooltip gets rendered at the wrong position,\n            // potentially causing scroll bars\n            height.value = tooltipBox$.value.offsetHeight;\n            width.value = tooltipBox$.value.offsetWidth;\n\n            updatePosition();\n\n            // wait for updated position to be effective and rendered, then enable transitions\n            await nextTick();\n            await new Promise((resolve) => requestAnimationFrame(resolve));\n            transitionPosition.value = true;\n        }\n\n        watch(() => props.preferredPosition, updatePosition);\n        function updatePosition() {\n            if (!isShown.value || !tooltipTrigger$.value) return;\n            // Note that in his method we do not need to use requestAnimationFrame to avoid reflows, as the method is\n            // already called as a scroll event listener or manually in update after a reflow.\n            // tslint:disable-next-line:prefer-const\n            let [preferredVerticalPosition, preferredHorizontalPosition] = props.preferredPosition.split(' ');\n            preferredHorizontalPosition = preferredHorizontalPosition || TooltipHorizontalPosition.RIGHT;\n            left.value = preferredHorizontalPosition === TooltipHorizontalPosition.RIGHT\n                ? Math.round(tooltipTrigger$.value.offsetWidth / 2 - 25) // offset by 25px according to designs\n                : Math.round(tooltipTrigger$.value.offsetWidth / 2 - width.value + 25);\n\n            if (props.container) {\n                // position tooltip such that it best fits container element\n                const triggerBoundingRect = tooltipTrigger$.value.getBoundingClientRect();\n                const containerBoundingRect = props.container.getBoundingClientRect();\n                const topMargin = getMargin(TooltipVerticalPosition.TOP) || 0;\n                const bottomMargin = getMargin(TooltipVerticalPosition.BOTTOM) || 0;\n                const spaceNeeded = height.value + 16; // 16 for arrow, assuming same height on mobile for simplicity\n                const fitsTop = triggerBoundingRect.top - containerBoundingRect.top - topMargin >= spaceNeeded;\n                const fitsBottom = containerBoundingRect.bottom - triggerBoundingRect.bottom - bottomMargin >= spaceNeeded;\n                if ((preferredVerticalPosition === TooltipVerticalPosition.TOP && (fitsTop || !fitsBottom))\n                    || (preferredVerticalPosition === TooltipVerticalPosition.BOTTOM) && (fitsTop && !fitsBottom)) {\n                    verticalPosition.value = TooltipVerticalPosition.TOP;\n                } else {\n                    verticalPosition.value = TooltipVerticalPosition.BOTTOM;\n                }\n\n                // constrain horizontal position\n                const leftMargin = getMargin(TooltipHorizontalPosition.LEFT) || 0;\n                const rightMargin = getMargin(TooltipHorizontalPosition.RIGHT) || 0;\n                // left and right bound of container, expressed in trigger's coordinate system\n                const leftBound = containerBoundingRect.left + leftMargin - triggerBoundingRect.left;\n                const rightBound = containerBoundingRect.right - rightMargin - triggerBoundingRect.left;\n                left.value = Math.max(\n                    leftBound,\n                    Math.min(\n                        rightBound - width.value,\n                        left.value,\n                    ),\n                );\n            } else {\n                verticalPosition.value = preferredVerticalPosition as TooltipVerticalPosition;\n            }\n\n            top.value = verticalPosition.value === TooltipVerticalPosition.BOTTOM\n                ? tooltipTrigger$.value.offsetHeight\n                : -height.value;\n        }\n\n        watch(() => props.container, setContainer);\n        async function setContainer(newContainer?: HTMLElement, oldContainer?: HTMLElement) {\n            if (oldContainer) {\n                oldContainer.removeEventListener('scroll', updatePosition);\n            }\n\n            if (newContainer) {\n                // In case the container is scrollable add a listener\n                await new Promise((resolve) => requestAnimationFrame(()  => {\n                    if (newContainer.scrollHeight !== newContainer.offsetHeight) {\n                        newContainer.addEventListener('scroll', updatePosition);\n                    }\n                    resolve(null);\n                }));\n            }\n\n            await update();\n        }\n\n        function getMargin(position: TooltipVerticalPosition | TooltipHorizontalPosition) {\n            if (props.margin && props.margin[position] !== undefined) return props.margin[position];\n\n            const containerEl = props.container || null;\n            if (!containerEl) return 0;\n\n            if ((position === TooltipVerticalPosition.TOP || position === TooltipVerticalPosition.BOTTOM)\n                && containerEl.scrollHeight !== containerEl.offsetHeight) {\n                // If container is scrollable, the padding scrolls with the content. Therefore we consider the whole\n                // offsetHeight as valid area for the tooltip and return a margin of 0.\n                return 0;\n            }\n            return parseInt(window.getComputedStyle(containerEl, null).getPropertyValue(`padding-${position}`), 10);\n        }\n\n        function mouseOver(mouseOverTooltip: boolean) {\n            if (!mouseOverTooltip) { // mouseleave\n                mouseOverTimeout.value = window.setTimeout(\n                    () => mousedOver.value = false,\n                    100,\n                );\n            } else { // mouseenter\n                if (mouseOverTimeout.value) window.clearTimeout(mouseOverTimeout.value);\n                mousedOver.value = true;\n            }\n        }\n\n        function onClick() {\n            if (Date.now() - lastToggle.value < 200) return; // just toggled by mouseover or focus\n            toggle(/* force */ true);\n            context.emit('click');\n        }\n\n        context.expose({ show, hide, toggle, update });\n\n        return {\n            TooltipThemes,\n\n            tooltipTrigger$,\n            tooltipBox$,\n            root$,\n\n            verticalPosition,\n            transitionPosition,\n\n            isShown,\n            tooltipBoxStyles,\n\n            show,\n            hide,\n            mouseOver,\n            onClick,\n        };\n    },\n    components: { AlertTriangleIcon }\n})\n</script>\n\n<style scoped>\n    .tooltip {\n        display: inline-block;\n        position: relative;\n        line-height: 1;\n    }\n\n    .trigger {\n        position: relative;\n        display: inline-block;\n        vertical-align: bottom;\n        text-decoration: none;\n        outline: none;\n        cursor: default;\n        color: inherit;\n    }\n\n    .trigger:deep(svg:first-child:last-child),\n    .trigger:deep(img:first-child:last-child) {\n        display: block;\n    }\n\n    .trigger::after {\n        opacity: 0;\n        content: '';\n        display: block;\n        position: absolute;\n        width: 2.25rem;\n        height: 2rem;\n        left: calc(50% - 1.125rem);\n        mask-image: url('data:image/svg+xml,<svg viewBox=\"0 0 18 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9 7.12c-.47 0-.93.2-1.23.64L3.2 14.29A4 4 0 0 1 0 16h18a4 4 0 0 1-3.2-1.7l-4.57-6.54c-.3-.43-.76-.64-1.23-.64z\" fill=\"white\"/></svg>');\n        transition: opacity .3s var(--nimiq-ease), .3s visibility;\n        transition-delay: 16ms; /* delay one animation frame for better sync with tooltipBox */\n        visibility: hidden;\n        z-index: 1000; /* move above tooltip-box's box-shadow */\n    }\n\n    .transition-position .trigger::after {\n        transition: top .2s var(--nimiq-ease), left .2s var(--nimiq-ease), transform .2s var(--nimiq-ease),\n            opacity .3s var(--nimiq-ease), .3s visibility;\n    }\n\n    .top .trigger::after {\n        top: -2rem;\n        background: #250636; /* a color of the nimiq-blue-bg gradient in the lower area */\n        transform: scaleY(-1);\n    }\n\n    .bottom .trigger::after {\n        top: 100%;\n        background: #201e45; /* a color of the nimiq-blue-bg gradient in the upper area */\n    }\n\n    .inverse-theme .trigger::after {\n        background: white;\n    }\n\n    .shown .trigger::after {\n        opacity: 1;\n        visibility: visible;\n    }\n\n    .tooltip-box {\n        position: absolute;\n        color: white;\n        background: var(--nimiq-blue-bg);\n        padding: 1.5rem;\n        border-radius: .5rem;\n        font-size: 1.75rem;\n        line-height: 1.5;\n        font-weight: 600;\n        transition: opacity .3s var(--nimiq-ease);\n        box-shadow: 0 1.125rem 2.275rem rgba(0, 0, 0, 0.11);\n        z-index: 999;\n    }\n\n    .inverse-theme .tooltip-box {\n        color: var(--nimiq-blue);\n        background: white;\n    }\n\n    .transition-position .tooltip-box {\n        transition: opacity .3s var(--nimiq-ease), transform .2s var(--nimiq-ease), top .2s var(--nimiq-ease);\n    }\n\n    .tooltip-box.transition-fade-enter,\n    .tooltip-box.transition-fade-leave-to {\n        opacity: 0;\n    }\n\n    .top .tooltip-box {\n        transform: translateY(-2rem);\n    }\n\n    .bottom .tooltip-box {\n        transform: translateY(2rem);\n    }\n</style>\n"],"names":["_resolveComponent","_createElementBlock","_normalizeClass","_ctx","_cache","$event","_withModifiers","_createCommentVNode","_renderSlot","_hoisted_1","_Transition","_withCtx","_openBlock","_normalizeStyle"],"mappings":";;;;;;;YACIA,EA+BO,mBAAA;cA9BoDC,EAAA,QAAA;AAAA,IAAA,OAAAC,EAAA,CAAA,WAAqC,CAAkBC,EAAA,kBAAA;AAAA,MAAA,OAAAA,EAAA;AAAA;MADxF,iBAAOA,EAAA,UAAAA,EAAA,cAAA;AAAA,IAM5B,CAAA,CAAA,CAAA;AAAA,IACA,KAAA;AAAA,IAAA,cAAAC,EAAA,OAAAA,EAAA,KAAA,CAAAC,MAAAF,EAAA,UAAA,EAAA;AAAA,IAED,cAaIC,EAAA,OAAAA,EAAA,KAAA,CAAAC,MAAAF,EAAA,UAAA,EAAA;AAAA,EAAA,GAAA;AAAA,MAZI,KAAiB;AAAA,MACpB,MAAA;AAAA,MACA,KAAA;AAAA,MACA,SAAKC,kBAAE,CAAOC,MAAAF,EAAA,KAAA,GAAA,CAAA,MAAA,CAAA;AAAA,MACd,QAAQC,EAAE,OAAAA,EAAY,KAAOE,EAAA,CAAAD,MAAAF,EAAA,KAAA,GAAA,CAAA,MAAA,CAAA;AAAA,MAC9B,SAAMC,EAAS,OAAAA,EAAA,KAAA,CAAAC,MAAAF,EAAA;MAAA,UAAAA,EAAA,YAAAA,EAAA,UAAA,KAAA;AAAA,MAEF,OAAA;AAAA,IAAA,GAAA;AAAA,MACTA,EAAA,OAAA,OAGJI,EAA+D,IAAA,EAAA,IAH3DC,EAAAL,EAAA,QAAA,WAAA,EAAA,KAAA,EAAA,GAAA,MAAA;AAAA;MAGQ,GAAA,EAAA;AAAA,MAEhBA,EAAA,OAAA,QAAA,CAAAA,EAAA,OAAA,UAAAK,EAAAL,EAAA,QAAA,QAAA,EAAA,KAAA,EAAA,GAAA,QAAA,EAAA,IAAAI,EAOa,IAPD,EAAK;AAAA,IAAA,GAAA,IAAAE,CAAA;AAAA,MAEHC,GAAO,EAAA,MAAA,kBAAA,GAAA;AAAA,MADjB,SAAAC,EAAA,MAAA;AAAA,QAAAR,EAAA,WAAAS,KAAsBX,EAAA,OAAA;AAAA,UAElB,KAAK;AAAA,UACJ,KAAK;AAAA,UAAA,OAAA;AAAA,UACN,OAAaY,EAAAV,EAAA,gBAAA;AAAA,QAAA,GAAA;AAAA;;;;;;;;"}