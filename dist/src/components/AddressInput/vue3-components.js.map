{"version":3,"file":"vue3-components.js","sources":["../../../../src/components/AddressInput/AddressInput.vue"],"sourcesContent":["<template>\n    <div class=\"address-input\" :class=\"{\n        'display-as-nim-address': displayAsNimAddress,\n        'display-as-domain': displayAsDomain,\n    }\" ref=\"root$\">\n        <textarea ref=\"textarea$\" spellcheck=\"false\" autocomplete=\"off\"\n            :placeholder=\"allowNimAddresses === allowEthAddresses ? undefined : allowNimAddresses ? 'NQ' : '0x'\"\n            @keydown=\"onKeyDown\" @input=\"onInput\" @paste=\"onPaste\" @cut=\"onCut\" @copy=\"formatClipboard\"\n            @click=\"updateSelection\" @select=\"updateSelection\" @blur=\"updateSelection\" @focus=\"onFocus\"\n        ></textarea>\n\n        <template v-if=\"displayAsNimAddress && supportsMixBlendMode\">\n            <template v-for=\"row in 3\">\n                <template v-for=\"column in 3\" :key=\"`color-${row}-${column}`\">\n                    <div class=\"color-overlay\" :style=\"{\n                        /* Hidden when placeholder shown. Visibility instead of v-if to avoid flickering in Firefox */\n                        visibility: currentValue ? 'visible' : 'hidden',\n                        left: `calc(${column - 1} * (var(--block-width) + var(--block-gap-h)) + var(--block-gap-h) - 0.25rem)`,\n                        top: `calc(${row - 1} * (var(--block-height) + var(--block-gap-v)) + var(--block-gap-v) + 0.25rem)`,\n                        background: `var(--nimiq-${isBlockFocused((row - 1) * 3 + (column - 1)) ? 'light-' : ''}blue)`,\n                    }\"></div>\n                </template>\n            </template>\n        </template>\n\n        <transition name=\"transition-fade\">\n            <svg v-if=\"!displayAsDomain\" width=\"210\" height=\"99\" viewBox=\"0 0 210 99\" stroke-width=\"1.5\"\n                stroke-linecap=\"round\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"grid\">\n                <line x1=\"0.75\" y1=\"30.25\" x2=\"209.25\" y2=\"30.25\"/> <!-- 1st horizontal line -->\n                <line x1=\"0.75\" y1=\"68.25\" x2=\"209.25\" y2=\"68.25\"/> <!-- 2nd horizontal line -->\n                <transition name=\"transition-fade\">\n                    <g v-if=\"displayAsNimAddress\">\n                        <line x1=\"67.75\" y1=\"0.75\" x2=\"67.75\" y2=\"22.25\"/> <!-- left vertical line in 1st row -->\n                        <line x1=\"143.75\" y1=\"0.75\" x2=\"143.75\" y2=\"22.25\"/> <!-- right vertical line in 1st row -->\n                        <line x1=\"67.75\" y1=\"37.75\" x2=\"67.75\" y2=\"60.25\"/> <!-- left vertical line in 2nd row -->\n                        <line x1=\"143.75\" y1=\"37.75\" x2=\"143.75\" y2=\"60.25\"/> <!-- right vertical line in 2nd row -->\n                        <line x1=\"67.75\" y1=\"75.75\" x2=\"67.75\" y2=\"98.25\"/> <!-- left vertical line in 3rd row -->\n                        <line x1=\"143.75\" y1=\"75.75\" x2=\"143.75\" y2=\"98.25\"/> <!-- right vertical line in 3rd row -->\n                    </g>\n                </transition>\n            </svg>\n        </transition>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, onMounted, onUnmounted, ref, watch } from 'vue';\nimport {\n    onChange as inputFormatOnChange,\n    onPaste as inputFormatOnPaste,\n    onCut as inputFormatOnCut,\n    onKeyDown as inputFormatOnKeyDown,\n    // @ts-expect-error Could not find a declaration file for module 'input-format'.\n} from 'input-format';\nimport { Clipboard, ValidationUtils } from '@nimiq/utils';\n\ninterface ParserFlags {\n    allowNimAddresses: boolean;\n    allowEthAddresses: boolean;\n    allowDomains: boolean;\n}\n\nconst ADDRESS_REPLACED_CHARS: Partial<Record<string, string>> = {\n    O: '0',\n    I: '1',\n    Z: '2',\n};\n\nconst NIM_ADDRESS_MAX_LENGTH = /* 9 blocks */ 9 * /* 4 chars each */ 4 + /* spaces between */ 8;\nconst NIMIQ_ADDRESS_REGEX = new RegExp('^(?:'\n    + 'NQ?' // NQ at the beginning\n    + '|NQ\\\\d{1,2}' // first two characters after starting NQ must be digits\n    // valid address <= max len; excluding invalid address characters I, O, W, Z which are the only characters\n    // missing in Nimiq's base32 address alphabet.\n    + `|NQ\\\\d{2}[0-9A-HJ-NP-VXY]{1,${NIM_ADDRESS_MAX_LENGTH - 4 - /* spaces */ 8}}`\n    + ')$', 'i');\n\nconst ETH_ADDRESS_MAX_LENGTH = /* \"0x\" */ 2 + /* ETH addresses are 20 bytes, hex encoded */ 40;\nconst ETH_ADDRESS_REGEX = new RegExp('^(?:'\n    + '0x?' // 0x at the beginning\n    + `|0x[0-9a-f]{1,${ETH_ADDRESS_MAX_LENGTH - /* \"0x\" */ 2}}` // valid address <= max length\n    + ')$', 'i');\n\nconst DOMAIN_REGEX = new RegExp('^'\n    + '[-a-z0-9]*' // allow hyphens, Latin letters and numbers at the beginning\n    + '(?:[a-z0-9]\\\\.[a-z]*)?' // can contain one dot before which no hyphen is allowed and after only Latin letters\n    + '$', 'i');\n\nconst WHITESPACE_REGEX = /\\s|\\u200B/g; // normal whitespace, tab, newline or zero-width space\n\n// definiton of the parse method for input-format (https://github.com/catamphetamine/input-format#usage)\n// The parse method is called on every change to the textarea's content, on the entire content, one character at a\n// time. The parsed content is then formatted via _format and written back to the textarea.\nfunction parse(char: string, value: string, parserFlags: ParserFlags) {\n    if (WHITESPACE_REGEX.test(char)) return; // skip whitespace as it will be added during formatting\n\n    const addressChar = /* enable char replacement once address prefix NQ or 0x have been typed */ value.length >= 2\n        ? ADDRESS_REPLACED_CHARS[char.toUpperCase()] || char\n        : char;\n    if (willBeNimAddress(value + addressChar, parserFlags)) {\n        // We return the original character without transforming it to uppercase to improve compatibility with some\n        // browsers that struggle with undo/redo of manipulated input. The actual transformation to uppercase is\n        // then done via CSS and when the value is exported.\n        return addressChar;\n    } else if (willBeEthAddress(value + addressChar, parserFlags)) {\n        if (value === '0' && addressChar === 'X') return 'x'; // Convert 0X prefix to more common 0x.\n        return addressChar;\n    } else if (willBeDomain(value + char, parserFlags)) {\n        return char;\n    }\n    // else reject / skip character\n}\n\n// definiton of the format method for input-format (https://github.com/catamphetamine/input-format#usage)\nfunction format(value: string, parserFlags: ParserFlags) {\n    if (willBeNimAddress(value, parserFlags)) {\n        value = stripWhitespace(value)\n            .replace(/.{4}/g, (match, offset) => `${match}${(offset + 4) % 12 ? ' ' : '\\n'}`) // form blocks\n            .substring(0, NIM_ADDRESS_MAX_LENGTH); // discarding the new line after last block\n\n        if (value.endsWith(' ')) {\n            // The word spacing set via css is only applied to spaces that are actually between words which is not\n            // the case for an ending space and the caret after an ending space therefore gets rendered at the wrong\n            // position. To avoid that we add a zero-width space as an artificial word. We do not add that to the\n            // template returned to input-format though to avoid it being interpreted as a typed character which\n            // would place the caret after the zero width space.\n            value += '\\u200B';\n        }\n        return {\n            text: value,\n            // Used by input-format to position caret. Using w as placeholder instead of default x as w is not in\n            // our address alphabet.\n            template: 'wwww wwww wwww\\nwwww wwww wwww\\nwwww wwww wwww',\n        };\n    } else if (willBeEthAddress(value, parserFlags)) {\n        value = stripWhitespace(value)\n            .replace(/.{14}/g, (match) => `${match}\\n`) // form blocks\n            .substring(0, ETH_ADDRESS_MAX_LENGTH + /* new lines */ 2); // discard new line at end\n\n        return {\n            text: value,\n            template: 'wwwwwwwwwwwwww\\nwwwwwwwwwwwwww\\nwwwwwwwwwwwwww',\n        };\n    } else {\n        return {\n            text: value,\n        };\n    }\n}\n\nfunction stripWhitespace(value: string) {\n    return value.replace(WHITESPACE_REGEX, '');\n}\n\nfunction exportValue(value: string, parserFlags: ParserFlags) {\n    if (willBeNimAddress(value, parserFlags)) {\n        return value.toUpperCase().replace(/\\n/g, ' ').replace(/\\u200B/g, '');\n    } else {\n        return value.replace(/\\n/g, '').replace(/\\u200B/g, '');\n    }\n}\n\nfunction willBeNimAddress(value: string, parserFlags: ParserFlags): boolean {\n    return parserFlags.allowNimAddresses && NIMIQ_ADDRESS_REGEX.test(stripWhitespace(value));\n}\n\nfunction willBeEthAddress(value: string, parserFlags: ParserFlags): boolean {\n    return parserFlags.allowEthAddresses && ETH_ADDRESS_REGEX.test(stripWhitespace(value));\n}\n\nfunction willBeDomain(value: string, parserFlags: ParserFlags): boolean {\n    return parserFlags.allowDomains\n        && !!value.length // expect at least one char\n        && DOMAIN_REGEX.test(value)\n        && !willBeNimAddress(value, parserFlags)\n        && !willBeEthAddress(value, parserFlags);\n}\n\n// Simplified from @ethersproject/address, which we don't use directly to avoid its unnecessary dependencies.\nasync function isEthAddress(address: string) {\n    if (!/^0x[0-9a-f]{40}$/i.test(address)) {\n        // Check if it has the basic requirements of an address.\n        return false;\n    } else if (!/[a-f]/.test(address) || !/[A-F]/.test(address)) {\n        // If it's all uppercase or all lowercase (ignoring the x of 0x) there is no encoded checksum to check.\n        return true;\n    } else {\n        // Check checksum encoded in uppercase and lowercase characters.\n        const addressHex = address.replace(/0x/gi, '');\n        const addressHexCharCodes = addressHex.toLowerCase().split('').map((char) => char.charCodeAt(0));\n        // External dependency which can be shared with the consuming app and which is lazy loaded only when needed.\n        const { keccak_256 } = await import('js-sha3');\n        const hashHex = keccak_256(addressHexCharCodes);\n\n        for (let i = 0; i < 40; i++) {\n            // Address hex char at position i should be uppercase if the decimal value of hash hex char at position\n            // i is >= 8, and lowercase otherwise.\n            if ((parseInt(hashHex[i], 16) >= 8 ? addressHex[i].toUpperCase() : addressHex[i].toLowerCase())\n                !== addressHex[i]) return false;\n        }\n        return true;\n    }\n}\n\nexport enum AddressInputEvent {\n    PASTE = 'paste',\n    MODELVALUE_UPDATE = 'update:modelValue',\n    ADDRESS = 'address',\n}\n\nexport default defineComponent({\n    name: 'AddressInput',\n    emits: Object.values(AddressInputEvent),\n    props: {\n        // value that can be bound to via v-model\n        modelValue: {\n            type: String,\n            default: '',\n        },\n        autofocus: Boolean,\n        allowNimAddresses: {\n            type: Boolean,\n            default: true,\n        },\n        allowEthAddresses: Boolean,\n        allowDomains: Boolean,\n    },\n    setup(props, context) {\n        const root$ = ref<HTMLDivElement | null>(null);\n        const textarea$ = ref<HTMLTextAreaElement | null>(null);\n\n        const currentValue = ref('');\n        const selectionStartBlock = ref(-1);\n        const selectionEndBlock = ref(-1);\n        const supportsMixBlendMode: boolean = CSS.supports('mix-blend-mode', 'screen');\n\n        const parserFlags = computed(() => ({\n            allowNimAddresses: props.allowNimAddresses,\n            allowEthAddresses: !!props.allowEthAddresses,\n            allowDomains: !!props.allowDomains,\n        }));\n\n        // initlially display as Nim address by default if Nim is the only allowed address type or no Eth is allowed and\n        // no value is set yet.\n        const displayAsNimAddress = computed(() =>\n            (props.allowNimAddresses && !props.allowEthAddresses && (!props.allowDomains || !currentValue.value))\n                || willBeNimAddress(currentValue.value, parserFlags.value)\n        );\n\n        const displayAsDomain = computed(() =>\n            (props.allowDomains && !props.allowNimAddresses && !props.allowEthAddresses)\n                || willBeDomain(currentValue.value, parserFlags.value)\n        );\n\n        onMounted(() => {\n            // trigger initial value change. Not using immediate watcher as it already fires before mounted.\n            onExternalValueChange();\n\n            // Add selectionchange event handler. It has to be registered on document and is unfortunately not fired for\n            // selections in textareas in Firefox. Therefore, we also bind the listener to focus, blur, select, click.\n            document.addEventListener('selectionchange', updateSelection);\n\n            if (props.autofocus) focus();\n        });\n\n        onUnmounted(() => {\n            document.removeEventListener('selectionchange', updateSelection);\n        });\n\n        function focus(scrollIntoView = false) {\n            const textarea = textarea$.value;\n            if (!textarea) return;\n\n            textarea.focus();\n            if (scrollIntoView) textarea.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        }\n\n        watch(() => props.modelValue, () => onExternalValueChange());\n        function onExternalValueChange() {\n            if (stripWhitespace(props.modelValue) === stripWhitespace(currentValue.value)) return;\n\n            // could also be using format-input's parse and format helpers that preserve caret position but as we're not\n            // interested in that, we calculate the formatted value manually\n            const parsedValue = props.modelValue.split('').reduce((parsed, char) =>\n                parsed + (parse(char, parsed, parserFlags.value) || ''), '');\n\n            if (textarea$.value) {\n                textarea$.value.value = format(parsedValue, parserFlags.value).text; // moves caret to the end\n            }\n\n            afterChange(parsedValue);\n        }\n\n        function onKeyDown(e: KeyboardEvent) {\n            inputFormatOnKeyDown(\n                e,\n                textarea$.value,\n                (char: string, value: string) => parse(char, value, parserFlags.value),\n                (value: string) => format(value, parserFlags.value),\n                afterChange,\n            );\n            setTimeout(() => updateSelection(), 10); // for arrow keys in Firefox\n        }\n\n        function onInput(e: Event & { inputType?: string }) {\n            if (e.inputType === 'deleteByDrag') return; // we'll handle the subsequent insertFromDrop\n            const textarea = textarea$.value;\n            inputFormatOnChange(\n                e,\n                textarea,\n                (char: string, value: string) => parse(char, value, parserFlags.value),\n                (value: string) => format(value, parserFlags.value),\n                afterChange,\n            );\n        }\n\n        function onPaste(e: ClipboardEvent) {\n            const clipboardData = e.clipboardData;\n            const pastedData = clipboardData ? clipboardData.getData('text/plain') : '';\n            context.emit(AddressInputEvent.PASTE, e, pastedData);\n\n            inputFormatOnPaste(\n                e,\n                textarea$.value,\n                (char: string, value: string) => parse(char, value, parserFlags.value),\n                (value: string) => format(value, parserFlags.value),\n                afterChange,\n            );\n        }\n\n        function onCut(e: ClipboardEvent) {\n            inputFormatOnCut(\n                e,\n                textarea$.value,\n                (char: string, value: string) => parse(char, value, parserFlags.value),\n                (value: string) => format(value, parserFlags.value),\n                afterChange,\n            );\n            formatClipboard();\n        }\n\n        function onFocus() {\n            // have to add a delay because the textarea is not focused yet at this point\n            setTimeout(() => updateSelection());\n        }\n\n        function formatClipboard() {\n            // While it's possible to set the clipboard data via clipboardEvent.clipboardData.setData this requires\n            // calling preventDefault() which then results in the need to reimplement the behavior for cutting text and\n            // has side effects like the change not being added to the undo history. Therefore, we let the browser do\n            // the default behavior but overwrite the clipboard afterwards.\n            const text = exportValue(document.getSelection()!.toString(), parserFlags.value);\n            setTimeout(() => Clipboard.copy(text));\n        }\n\n        async function afterChange(value: string) {\n            const textarea = textarea$.value;\n            if (!textarea) return;\n            // textarea.value is the unformatted value (i.e. the concatenation of characters returned by parse)\n\n            // if selection is a caret in front of a space or new line move caret behind it\n            if (textarea.selectionStart === textarea.selectionEnd\n                && /\\s/.test(textarea.value[textarea.selectionStart])) {\n                textarea.selectionStart += 1; // this also moves the selectionEnd as they were equal\n            }\n\n            currentValue.value = exportValue(textarea.value, parserFlags.value);\n            context.emit(AddressInputEvent.MODELVALUE_UPDATE, currentValue.value); // emit event compatible with v-model\n\n            if (willBeNimAddress(value, parserFlags.value)) {\n                const isValid = ValidationUtils.isValidAddress(currentValue.value);\n                if (isValid) context.emit(AddressInputEvent.ADDRESS, currentValue.value);\n\n                if (!root$.value) return;\n                // if user entered a full address that is not valid give him a visual feedback\n                root$.value.classList.toggle(\n                    'invalid',\n                    currentValue.value.length === NIM_ADDRESS_MAX_LENGTH && !isValid,\n                );\n            } else if (willBeEthAddress(value, parserFlags.value)) {\n                const checkedValue = currentValue.value; // make copy because currentValue might change during async request\n                const isValid = await isEthAddress(stripWhitespace(checkedValue));\n                if (isValid) context.emit(AddressInputEvent.ADDRESS, checkedValue);\n\n                if (!root$.value) return;\n                // if user entered a full address that is not valid give him a visual feedback\n                root$.value.classList.toggle(\n                    'invalid',\n                    checkedValue.length === ETH_ADDRESS_MAX_LENGTH && !isValid,\n                );\n            }\n        }\n\n        function updateSelection() {\n            const textarea = textarea$.value;\n            if (!textarea) return;\n            const focused = document.activeElement === textarea\n                // If all blocks are filled and the caret is at the end display as if not focused.\n                && (textarea.selectionStart !== NIM_ADDRESS_MAX_LENGTH\n                || textarea.selectionEnd !== NIM_ADDRESS_MAX_LENGTH);\n            selectionStartBlock.value = focused ? Math.floor(textarea.selectionStart / 5) : -1;\n            selectionEndBlock.value = focused ? Math.floor(textarea.selectionEnd / 5) : -1;\n        }\n\n        function isBlockFocused(blockIndex: number) {\n            return selectionStartBlock.value <= blockIndex && blockIndex <= selectionEndBlock.value;\n        }\n\n        context.expose({ focus });\n\n        return {\n            root$,\n            textarea$,\n\n            currentValue,\n            supportsMixBlendMode,\n            displayAsNimAddress,\n            displayAsDomain,\n\n            onKeyDown,\n            onInput,\n            onPaste,\n            onCut,\n            onFocus,\n\n            formatClipboard,\n            updateSelection,\n            isBlockFocused,\n        };\n    },\n});\n</script>\n\n<style scoped>\n    .address-input {\n        --font-size: 3rem;\n        --block-height: 4.125rem;\n        --block-width: 8.5rem;\n        --block-gap-v: 0.75rem;\n        --block-gap-h: 1rem;\n\n        contain: size layout paint style;\n        width: calc(3 * var(--block-width) + 3 * var(--block-gap-h));\n        height: calc(3 * var(--block-height) + 3.5 * var(--block-gap-v));\n        position: relative;\n        background: white; /* Note: our text coloring with mix-blend-mode only works on white background */\n\n        border-radius: 0.5rem;\n        --border-color: rgba(31, 35, 72, 0.1); /* Based on Nimiq Blue */\n        box-shadow: inset 0 0 0 1.5px var(--border-color);\n        transition: box-shadow .2s ease, height 0.3s var(--nimiq-ease);\n        overflow: hidden;\n    }\n\n    .address-input.display-as-domain {\n        height: calc(var(--block-height) + 2 * var(--block-gap-v));\n    }\n\n    .address-input:hover {\n        --border-color: rgba(31, 35, 72, 0.14); /* Based on Nimiq Blue */\n    }\n\n    .address-input:focus-within {\n        --border-color: rgba(5, 130, 202, 0.4); /* Based on Nimiq Light Blue */\n    }\n\n    .address-input.invalid {\n        animation: shake .4s;\n    }\n\n    /* Copied from Keyguard */\n    @keyframes shake {\n        from { transform: none; }\n        10%  { transform: translate3d(-0.25rem, 0, 0) rotate(-0.15deg); }\n        20%  { transform: translate3d(0.5rem, 0, 0) rotate(0.15deg); }\n        30%  { transform: translate3d(-0.5rem, 0, 0) rotate(-0.15deg); }\n        40%  { transform: translate3d(0.5rem, 0, 0) rotate(0.15deg); }\n        50%  { transform: translate3d(-0.25rem, 0, 0) rotate(-0.15deg); }\n        to   { transform: none; }\n    }\n\n    textarea {\n        --line-height: calc(var(--block-height) + var(--block-gap-v));\n\n        contain: size layout paint style;\n        position: absolute;\n        width: 100%;\n        height: calc(3 * var(--line-height));\n        line-height: var(--line-height);\n        top: calc(var(--font-size) / 24 + var(--block-gap-v) / 2); /* -3px at default font size */\n        left: calc(var(--font-size) / 24 * 5 + var(--block-gap-h) / 2); /* 5px at default font size */\n        padding: 0;\n        margin: 0;\n        border: none;\n        outline: unset !important;\n        resize: none;\n        overflow: hidden;\n        z-index: 1;\n        /* Note: if loading only a subset of Fira Mono, the whitespace character must be included for rendering of\n        spaces at correct width in some browsers */\n        font-family: Fira Mono, 'monospace';\n        font-size: var(--font-size);\n        /* the width of rendered letters may slightly differ across different browsers on different OSs. To compensate\n        for that we apply a letter-spacing based on the deviation from a reference value */\n        letter-spacing: calc(1.8rem - 0.6em); /* 1ch changed to 0.6em, 'ch' in 'calc' making Safari 14.5 crash */\n        word-spacing: calc(var(--block-gap-h) / 2);\n        color: var(--nimiq-blue);\n        background: transparent;\n        transition: color 0.2s ease;\n    }\n\n    textarea:focus {\n        color: var(--nimiq-light-blue);\n    }\n\n    .display-as-domain textarea {\n        height: var(--line-height);\n        white-space: nowrap;\n        width: calc(100% - 2 * var(--block-gap-h))\n    }\n\n    .display-as-nim-address textarea {\n        text-transform: uppercase;\n        /* Mask image to make selections visible only within blocks. Using mask image instead clip path to be able to\n        click onto the textarea on the invisible areas too */\n        mask-image: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 123\"><rect x=\"-1\" y=\"6\" width=\"62\" height=\"28\"/><rect x=\"79\" y=\"6\" width=\"62\" height=\"28\"/><rect x=\"159\" y=\"6\" width=\"62\" height=\"28\"/><rect x=\"-1\" y=\"47\" width=\"62\" height=\"28\"/><rect x=\"79\" y=\"47\" width=\"62\" height=\"28\"/><rect x=\"159\" y=\"47\" width=\"62\" height=\"28\"/><rect x=\"-1\" y=\"88\" width=\"62\" height=\"28\"/><rect x=\"79\" y=\"88\" width=\"62\" height=\"28\"/><rect x=\"159\" y=\"88\" width=\"62\" height=\"28\"/></svg>');\n    }\n\n    @supports (mix-blend-mode: screen) {\n        .display-as-nim-address textarea {\n            color: black; /* the actual color will be set via mix-blend-mode */\n        }\n\n        .display-as-nim-address textarea::selection {\n            color: white;\n            background: #561a51; /* a color that in combination with mix-blend-mode yields a color close to the default */\n        }\n\n        .display-as-nim-address textarea::-moz-selection {\n            background: #411d68; /* a color that in combination with mix-blend-mode yields a color close to the default */\n        }\n\n        .color-overlay {\n            contain: size layout paint style;\n            position: absolute;\n            width: calc(var(--block-width) - .5rem);\n            height: calc(var(--block-height) - .5rem);\n            mix-blend-mode: screen;\n            z-index: 1;\n            pointer-events: none;\n        }\n    }\n\n    ::-webkit-input-placeholder {\n        opacity: .6;\n        transition: color .2s var(--nimiq-ease);\n    }\n    ::-ms-input-placeholder {\n        opacity: .6;\n        transition: color .2s var(--nimiq-ease);\n    }\n    ::-moz-placeholder {\n        opacity: .6;\n        transition: color .2s var(--nimiq-ease);\n    }\n    ::placeholder {\n        opacity: .6;\n        transition: color .2s var(--nimiq-ease);\n    }\n\n    textarea:focus::-webkit-input-placeholder {\n        color: var(--nimiq-light-blue);\n    }\n    textarea:focus::-ms-input-placeholder {\n        color: var(--nimiq-light-blue);\n    }\n    textarea:focus::-moz-placeholder {\n        color: var(--nimiq-light-blue);\n    }\n    textarea:focus::placeholder {\n        color: var(--nimiq-light-blue);\n    }\n\n    .grid {\n        contain: size layout paint style;\n        position: absolute;\n        top: calc(var(--font-size) / 24 * 8 + var(--block-gap-v) / 2);\n        left: calc(var(--font-size) / 24 * 5 + var(--block-gap-h) / 2);\n        stroke: var(--border-color);\n        transition: stroke .2s ease, opacity 0.2s ease;\n    }\n\n    textarea:focus ~ .grid {\n        opacity: 0.5;\n    }\n\n    .grid g {\n        transition: opacity .2s ease;\n    }\n\n    .grid.transition-fade-enter-from,\n    .grid.transition-fade-leave-to,\n    .grid g.transition-fade-enter-from,\n    .grid g.transition-fade-leave-to {\n        opacity: 0 !important;\n    }\n</style>\n"],"names":["_hoisted_2","_hoisted_3","_withScopeId","_createElementVNode","_hoisted_4","_hoisted_5","_hoisted_6","_hoisted_7","_hoisted_8","_hoisted_9","_hoisted_10","_hoisted_11","_hoisted_12","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_openBlock","_createElementBlock","_normalizeClass","args","_hoisted_1","_Fragment","_renderList","row","column","_normalizeStyle","_createCommentVNode","_createVNode","_Transition","_withCtx"],"mappings":"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"}