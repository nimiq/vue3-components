{"version":3,"file":"vue3-components.js","sources":["../../../../src/components/AddressInput/AddressInput.vue"],"sourcesContent":["<template>\n    <div class=\"address-input\" :class=\"{ 'is-domain': isDomain }\" ref=\"root$\">\n        <textarea ref=\"textarea$\" spellcheck=\"false\" autocomplete=\"off\"\n            :class=\"{'will-be-address': willBeAddressBool}\"\n            @keydown=\"onKeyDown\" @input=\"onInput\" @paste=\"onPaste\" @cut=\"onCut\" @copy=\"formatClipboard\"\n            @click=\"updateSelection\" @select=\"updateSelection\" @blur=\"updateSelection\" @focus=\"onFocus\"\n        ></textarea>\n\n        <template v-if=\"willBeAddressBool && supportsMixBlendMode\">\n            <template v-for=\"row in 3\">\n                <template v-for=\"column in 3\" :key=\"`color-${row}-${column}`\">\n                    <div class=\"color-overlay\" :style=\"{\n                        /* Hidden when placeholder shown. Visibility instead of v-if to avoid flickering in Firefox */\n                        visibility: currentValue ? 'visible' : 'hidden',\n                        left: `calc(${column - 1} * (var(--block-width) + var(--block-gap-h)) + var(--block-gap-h) - 0.25rem)`,\n                        top: `calc(${row - 1} * (var(--block-height) + var(--block-gap-v)) + var(--block-gap-v) + 0.25rem)`,\n                        background: `var(--nimiq-${isBlockFocused((row - 1) * 3 + (column - 1)) ? 'light-' : ''}blue)`,\n                    }\"></div>\n                </template>\n            </template>\n        </template>\n\n        <svg width=\"210\" height=\"99\" viewBox=\"0 0 210 99\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" class=\"grid\">\n            <g stroke-width=\"1.5\" stroke-linecap=\"round\">\n                <line x1=\"67.75\" y1=\"0.75\" x2=\"67.75\" y2=\"22.25\"/>\n                <line x1=\"67.75\" y1=\"37.75\" x2=\"67.75\" y2=\"60.25\"/>\n                <line x1=\"67.75\" y1=\"75.75\" x2=\"67.75\" y2=\"98.25\"/>\n                <line x1=\"0.75\" y1=\"30.25\" x2=\"209.25\" y2=\"30.25\"/>\n                <line x1=\"0.75\" y1=\"68.25\" x2=\"209.25\" y2=\"68.25\"/>\n                <line x1=\"143.75\" y1=\"37.75\" x2=\"143.75\" y2=\"60.25\"/>\n                <line x1=\"143.75\" y1=\"0.75\" x2=\"143.75\" y2=\"22.25\"/>\n                <line x1=\"143.75\" y1=\"75.75\" x2=\"143.75\" y2=\"98.25\"/>\n            </g>\n        </svg>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, onMounted, onUnmounted, ref, watch } from 'vue';\nimport {\n    onChange as inputFormatOnChange,\n    onPaste as inputFormatOnPaste,\n    onCut as inputFormatOnCut,\n    onKeyDown as inputFormatOnKeyDown,\n    // @ts-expect-error Could not find a declaration file for module 'input-format'.\n} from 'input-format';\nimport { Clipboard, ValidationUtils } from '@nimiq/utils';\n\nexport const ADDRESS_MAX_LENGTH_WITHOUT_SPACES = 9 * 4;\nexport const ADDRESS_MAX_LENGTH = ADDRESS_MAX_LENGTH_WITHOUT_SPACES + 8;\n\n// definiton of the parse method for input-format (https://github.com/catamphetamine/input-format#usage)\nfunction parse(char: string, value: string, allowDomains = false) {\n    if (!allowDomains || willBeAddress(value + char)) {\n        // Handle I, O, W, Z which are the only characters missing in Nimiq's Base 32 address alphabet\n        switch (char.toUpperCase()) {\n            case 'I': char = '1'; break;\n            case 'O': char = '0'; break;\n            case 'Z': char = '2'; break;\n            case 'W': return; // reject character\n        }\n\n        const regex = new RegExp('^('\n            + 'N(Q?)' // NQ at the beginning\n            + '|NQ\\\\d{1,2}' // first two characters after starting NQ must be digits\n            + `|NQ\\\\d{2}[0-9A-Z]{1,${ADDRESS_MAX_LENGTH_WITHOUT_SPACES - 4}}` // valid address < max length\n            + ')$', 'i');\n\n        // We return the original character without transforming it to uppercase to improve compatibility with some\n        // browsers that struggle with undo/redo of manipulated input. The actual transformation to uppercase is then\n        // done via CSS and when the value is exported\n        if (regex.test(value + char)) return char;\n        else return; // reject character\n    } else {\n        // Reject non-URL formats while allowing typing URLs character by character\n        /**\n         * [-a-z0-9]    Allow hyphens, english letters and numbers\n         * [a-z0-9]\\.   Require a character or letter before the period (to prevent a period directly after a hyphen)\n         * [a-z]        Only allow characters, no numbers, after the period\n         */\n        if (/^[-a-z0-9]*([a-z0-9]\\.[a-z]*)?$/i.test(value + char)) return char;\n        else return; // reject character\n    }\n}\n\n// definiton of the format method for input-format (https://github.com/catamphetamine/input-format#usage)\nfunction format(value: string, allowDomains = false) {\n    if (!allowDomains || willBeAddress(value)) {\n        if (value !== '' && value.toUpperCase() !== 'N') {\n            value = stripWhitespace(value)\n                .replace(/.{4}/g, (match, offset) => `${match}${(offset + 4) % 12 ? ' ' : '\\n'}`) // form blocks\n                .substring(0, ADDRESS_MAX_LENGTH); // discarding the new line after last block\n\n            if (value.endsWith(' ')) {\n                // The word spacing set via css is only applied to spaces that are actually between words which is not\n                // the case for an ending space and the caret after an ending space therefore gets rendered at the wrong\n                // position. To avoid that we add a zero-width space as an artificial word. We do not add that to the\n                // template returned to input-format though to avoid it being interpreted as a typed character which\n                // would place the caret after the zero width space.\n                value += '\\u200B';\n            }\n        }\n        return {\n            text: value,\n            template: 'wwww wwww wwww\\nwwww wwww wwww\\nwwww wwww wwww', // used by input-format to position caret. Using\n            // w as placeholder instead of default x as w is not in our address alphabet.\n        };\n    } else {\n        return {\n            text: value,\n        };\n    }\n}\n\nfunction stripWhitespace(value: string) {\n    return value.replace(/\\s|\\u200B/g, ''); // normal whitespace, tabs, newlines or zero-width whitespace\n}\n\nfunction exportValue(value: string, allowDomains = false) {\n    if (!allowDomains || willBeAddress(value)) {\n        return value.toUpperCase().replace(/\\n/g, ' ').replace(/\\u200B/g, '');\n    } else {\n        return value.replace(/\\n/g, '').replace(/\\u200B/g, '');\n    }\n}\n\nfunction willBeAddress(value: string): boolean {\n    if (value.length < 3) return false;\n    if (value.toUpperCase().startsWith('NQ') && !isNaN(parseInt(value[2], 10))) return true;\n    return false;\n}\n\nexport enum AddressInputEvent {\n    PASTE = 'paste',\n    MODELVALUE_UPDATE = 'update:modelValue',\n    ADDRESS = 'address',\n}\n\nexport default defineComponent({\n    name: \"AddressInput\",\n    emits: Object.values(AddressInputEvent),\n    props: {\n        // value that can be bound to via v-model\n        modelValue: {\n            type: String,\n            default: '',\n        },\n        autofocus: Boolean,\n        allowDomains: Boolean,\n    },\n    setup(props, context) {\n        const root$ = ref<HTMLDivElement | null>(null);\n        const textarea$ = ref<HTMLTextAreaElement | null>(null);\n\n        const currentValue = ref('');\n        const selectionStartBlock = ref(-1);\n        const selectionEndBlock = ref(-1);\n        const supportsMixBlendMode: boolean = CSS.supports('mix-blend-mode', 'screen');\n\n        const willBeAddressBool = computed(() => !props.allowDomains || willBeAddress(currentValue.value));\n        const isDomain = computed(() => currentValue.value.length >= 3 && !willBeAddressBool.value);\n\n        onMounted(() => {\n            // trigger initial value change. Not using immediate watcher as it already fires before mounted.\n            onExternalValueChange();\n\n            // Bind selectionchange event handler. It has to be registered on document and is unfortunately not fired for\n            // selections in textareas in Firefox. Therefore we also bind the listener to focus, blur, select, click.\n\n            // this.updateSelection = this.updateSelection.bind(this);\n            document.addEventListener('selectionchange', updateSelection);\n\n            if (props.autofocus) focus();\n        });\n\n        onUnmounted(() => {\n            document.removeEventListener('selectionchange', updateSelection);\n        });\n\n        function focus(scrollIntoView = false) {\n            if (!textarea$.value) return;\n\n            textarea$.value.focus();\n            if (scrollIntoView) textarea$.value.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        }\n\n        watch(() => props.modelValue, () => onExternalValueChange());\n        function onExternalValueChange() {\n            if (stripWhitespace(props.modelValue) === stripWhitespace(currentValue.value)) return;\n\n            // could also be using format-input's parse and format helpers that preserve caret position but as we're not\n            // interested in that, we calculate the formatted value manually\n            const parsedValue = props.modelValue.split('').reduce((parsed, char) =>\n                parsed + (parse(char, parsed, props.allowDomains) || ''), '');\n\n            if (textarea$.value) {\n                textarea$.value.value = format(parsedValue, props.allowDomains).text; // moves the caret to the end\n            }\n\n            afterChange(parsedValue);\n        }\n\n        function onKeyDown(e: KeyboardEvent) {\n            inputFormatOnKeyDown(\n                e,\n                textarea$.value,\n                (char: string, value: string) => parse(char, value, props.allowDomains),\n                (value: string) => format(value, props.allowDomains),\n                afterChange,\n            );\n            setTimeout(() => updateSelection(), 10); // for arrow keys in Firefox\n        }\n\n        function onInput(e: Event & { inputType?: string }) {\n            if (e.inputType === 'deleteByDrag') return; // we'll handle the subsequent insertFromDrop\n            const textarea = textarea$.value;\n            inputFormatOnChange(\n                e,\n                textarea,\n                (char: string, value: string) => parse(char, value, props.allowDomains),\n                (value: string) => format(value, props.allowDomains),\n                afterChange,\n            );\n        }\n\n        function onPaste(e: ClipboardEvent) {\n            const clipboardData = e.clipboardData;\n            const pastedData = clipboardData ? clipboardData.getData('text/plain') : '';\n            context.emit(AddressInputEvent.PASTE, e, pastedData);\n\n            inputFormatOnPaste(\n                e,\n                textarea$.value,\n                (char: string, value: string) => parse(char, value, props.allowDomains),\n                (value: string) => format(value, props.allowDomains),\n                afterChange,\n            );\n        }\n\n        function onCut(e: ClipboardEvent) {\n            inputFormatOnCut(\n                e,\n                textarea$.value,\n                (char: string, value: string) => parse(char, value, props.allowDomains),\n                (value: string) => format(value, props.allowDomains),\n                afterChange,\n            );\n            formatClipboard();\n        }\n\n        function onFocus() {\n            // have to add a delay because the textarea is not focused yet at this point\n            setTimeout(() => updateSelection());\n        }\n\n        function formatClipboard() {\n            // While it's possible to set the clipboard data via clipboardEvent.clipboardData.setData this requires calling\n            // preventDefault() which then results in the need to reimplement the behavior for cutting text and has side\n            // effects like the change not being added to the undo history. Therefore we let the browser do the default\n            // behavior but overwrite the clipboard afterwards.\n            const text = exportValue(document.getSelection()!.toString(), props.allowDomains);\n            setTimeout(() => Clipboard.copy(text));\n        }\n\n        function afterChange(value: string) {\n            if (!textarea$.value) return;\n\n            // value is the unformatted value (i.e. the concatenation of characters returned by parse)\n            const textarea = textarea$.value;\n\n            // if selection is a caret in front of a space or new line move caret behind it\n            if (textarea.selectionStart === textarea.selectionEnd\n                && (textarea.value[textarea.selectionStart] === ' ' || textarea.value[textarea.selectionStart] === '\\n')) {\n                textarea.selectionStart += 1; // this also moves the selectionEnd as they were equal\n            }\n\n            currentValue.value = exportValue(textarea$.value.value, props.allowDomains);\n            context.emit(AddressInputEvent.MODELVALUE_UPDATE, currentValue.value); // emit event compatible with v-model\n\n            if (willBeAddress(value)) {\n                const isValid = ValidationUtils.isValidAddress(currentValue.value);\n                if (isValid) context.emit(AddressInputEvent.ADDRESS, currentValue.value);\n\n                if (root$.value) {\n                    // if user entered a full address that is not valid give him a visual feedback\n                    root$.value.classList.toggle('invalid', currentValue.value.length === ADDRESS_MAX_LENGTH && !isValid);\n                }\n            }\n        }\n\n        function updateSelection() {\n            if (!textarea$.value) return;\n\n            const textarea = textarea$.value;\n            const focused = document.activeElement === textarea\n                && (textarea.selectionStart !== ADDRESS_MAX_LENGTH // if all blocks are filled and the caret\n                || textarea.selectionEnd !== ADDRESS_MAX_LENGTH); // is at the end display as if not focused\n\n            selectionStartBlock.value = focused ? Math.floor(textarea.selectionStart / 5) : -1;\n            selectionEndBlock.value = focused ? Math.floor(textarea.selectionEnd / 5) : -1;\n        }\n\n        function isBlockFocused(blockIndex: number) {\n            return selectionStartBlock.value <= blockIndex && blockIndex <= selectionEndBlock.value;\n        }\n\n        context.expose({ focus });\n\n        return {\n            root$,\n            textarea$,\n\n            currentValue,\n            supportsMixBlendMode,\n            willBeAddressBool,\n            isDomain,\n\n            onKeyDown,\n            onInput,\n            onPaste,\n            onCut,\n            onFocus,\n\n            formatClipboard,\n            updateSelection,\n            isBlockFocused,\n        };\n    }\n})\n</script>\n\n<style scoped>\n    .address-input {\n        --font-size: 3rem;\n        --block-height: 4.125rem;\n        --block-width: 8.5rem;\n        --block-gap-v: 0.75rem;\n        --block-gap-h: 1rem;\n\n        width: calc(3 * var(--block-width) + 3 * var(--block-gap-h));\n        height: calc(3 * var(--block-height) + 3.5 * var(--block-gap-v));\n        position: relative;\n        background: white; /* Note: our text coloring with mix-blend-mode only works on white background */\n\n        border-radius: 0.5rem;\n        --border-color: rgba(31, 35, 72, 0.1); /* Based on Nimiq Blue */\n        box-shadow: inset 0 0 0 1.5px var(--border-color);\n        transition: box-shadow .2s ease, height 0.3s var(--nimiq-ease);\n        overflow: hidden;\n    }\n\n    .address-input.is-domain {\n        height: calc(var(--block-height) + 2 * var(--block-gap-v));\n    }\n\n    .address-input:hover {\n        --border-color: rgba(31, 35, 72, 0.14); /* Based on Nimiq Blue */\n    }\n\n    .address-input:focus-within {\n        --border-color: rgba(5, 130, 202, 0.4); /* Based on Nimiq Light Blue */\n    }\n\n    .address-input.invalid {\n        animation: shake .4s;\n    }\n\n    /* Copied from Keyguard */\n    @keyframes shake {\n        from { transform: none; }\n        10%  { transform: translate3d(-0.25rem, 0, 0) rotate(-0.15deg); }\n        20%  { transform: translate3d(0.5rem, 0, 0) rotate(0.15deg); }\n        30%  { transform: translate3d(-0.5rem, 0, 0) rotate(-0.15deg); }\n        40%  { transform: translate3d(0.5rem, 0, 0) rotate(0.15deg); }\n        50%  { transform: translate3d(-0.25rem, 0, 0) rotate(-0.15deg); }\n        to   { transform: none; }\n    }\n\n    textarea {\n        --line-height: calc(var(--block-height) + var(--block-gap-v));\n\n        position: absolute;\n        width: 100%;\n        height: calc(3 * var(--line-height));\n        line-height: var(--line-height);\n        top: calc(var(--font-size) / 24 + var(--block-gap-v) / 2); /* -3px at default font size */\n        left: calc(var(--font-size) / 24 * 5 + var(--block-gap-h) / 2); /* 5px at default font size */\n        padding: 0;\n        margin: 0;\n        border: none;\n        outline: unset !important;\n        resize: none;\n        overflow: hidden;\n        z-index: 1;\n        /* Note: if loading only a subset of Fira Mono, the whitespace character must be included for rendering of\n        spaces at correct width in some browsers */\n        font-family: Fira Mono, 'monospace';\n        font-size: var(--font-size);\n        /* the width of rendered letters may slightly differ across different browsers on different OSs. To compensate\n        for that we apply a letter-spacing based on the deviation from a reference value */\n        letter-spacing: calc(1.8rem - 0.6em); /* 1ch changed to 0.6em, 'ch' in 'calc' making Safari 14.5 crash */\n        word-spacing: calc(var(--block-gap-h) / 2);\n        color: var(--nimiq-blue);\n        background: transparent;\n        transition: color 0.2s ease;\n    }\n\n    .is-domain textarea {\n        height: var(--line-height);\n        white-space: nowrap;\n        width: calc(100% - 2 * var(--block-gap-h))\n    }\n\n    textarea:focus {\n        color: var(--nimiq-light-blue);\n    }\n\n    textarea.will-be-address {\n        text-transform: uppercase;\n        /* Mask image to make selections visible only within blocks. Using mask image instead clip path to be able to\n        click onto the textarea on the invisible areas too */\n        mask-image: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 123\"><rect x=\"-1\" y=\"6\" width=\"62\" height=\"28\"/><rect x=\"79\" y=\"6\" width=\"62\" height=\"28\"/><rect x=\"159\" y=\"6\" width=\"62\" height=\"28\"/><rect x=\"-1\" y=\"47\" width=\"62\" height=\"28\"/><rect x=\"79\" y=\"47\" width=\"62\" height=\"28\"/><rect x=\"159\" y=\"47\" width=\"62\" height=\"28\"/><rect x=\"-1\" y=\"88\" width=\"62\" height=\"28\"/><rect x=\"79\" y=\"88\" width=\"62\" height=\"28\"/><rect x=\"159\" y=\"88\" width=\"62\" height=\"28\"/></svg>');\n    }\n\n    .grid {\n        position: absolute;\n        top: calc(var(--font-size) / 24 * 8 + var(--block-gap-v) / 2);\n        left: calc(var(--font-size) / 24 * 5 + var(--block-gap-h) / 2);\n        stroke: var(--border-color);\n        transition: stroke .2s ease, opacity 0.2s ease;\n    }\n\n    textarea:focus ~ .grid {\n        opacity: 0.5;\n    }\n\n    .is-domain .grid {\n        opacity: 0 !important;\n    }\n\n    @supports (mix-blend-mode: screen) {\n        textarea.will-be-address {\n            color: black; /* the actual color will be set via mix-blend-mode */\n        }\n\n        textarea.will-be-address::selection {\n            color: white;\n            background: #561a51; /* a color that in combination with mix-blend-mode yields a color close to the default */\n        }\n\n        textarea.will-be-address::-moz-selection {\n            background: #411d68; /* a color that in combination with mix-blend-mode yields a color close to the default */\n        }\n\n        .color-overlay {\n            position: absolute;\n            width: calc(var(--block-width) - .5rem);\n            height: calc(var(--block-height) - .5rem);\n            mix-blend-mode: screen;\n            z-index: 1;\n            pointer-events: none;\n        }\n    }\n</style>\n"],"names":["_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_openBlock","_createElementBlock","_normalizeClass","args","_Fragment","_renderList","row","column","_createElementVNode","_normalizeStyle","_createCommentVNode"],"mappings":";;;;;;AACc,SAAAA,EAAAC,GAAAC,GAACC,GAAeC,GAAwBC,GAAAC,GAAA;SAAgBC,EAAO,GAAAC,EAAA,OAAA;AAAA,IAAA,OAAAC,EAAA,CAAA,iBAAA,EAAA,aAAAR,EAAA,SAAA,CAAA,CAAA;AAAA,IACrE,KAAA;AAAA,EAAA,GAAA;AAAA,MAAqC,YAAO;AAAA,MAAC,KAAA;AAAA,MACxC,YAAK;AAAA,MACL,cAAO;AAAA,MAAc,OAAKQ,EAAE,EAAA,mBAAAR,EAAA,kBAAA,CAAA;AAAA,MAAU,WAAKC,0BAAED,EAAO,aAAAA,EAAA,UAAA,GAAAS,CAAA;AAAA,MAAG,SAAGR,0BAAED,EAAK,WAAAA,EAAA,QAAA,GAAAS,CAAA;AAAA,MAAG,SAAIR,EAAE,OAAAA,EAAA,KAAA,IAAAQ,MAAAT,EAAA,WAAAA,EAAA,QAAA,GAAAS,CAAA;AAAA,MAC1E,OAAKR,EAAE,OAAAA,EAAA,KAAA,IAAAQ,MAAAT,EAAA,SAAAA,EAAA,MAAA,GAAAS,CAAA;AAAA,MAAkB,QAAMR,EAAE,OAAAA,EAAA,KAAA,IAAAQ,MAAAT,EAAA,mBAAAA,EAAA,gBAAA,GAAAS,CAAA;AAAA,MAAkB,SAAIR,0BAAED,EAAe,mBAAAA,EAAA,gBAAA,GAAAS,CAAA;AAAA,MAAG,UAAKR,0BAAED,EAAO,mBAAAA,EAAA,gBAAA,GAAAS,CAAA;AAAA,MAAA,QAAAR,EAAA,OAAAA,EAAA,KAAA,IAAAQ,MAAAT,EAAA,mBAAAA,EAAA,gBAAA,GAAAS,CAAA;AAAA,MAG9E,SAAAR,EAAA,OAAiBA,EAAI,KAAoB,IAAAQ,MAAAT,EAAA,WAAAA,EAAA,QAAA,GAAAS,CAAA;AAAA,IAAA,GAAA,MAAA,EAAA;AAAA,4DAEjDC,GAQW,EAAA,KAAA,EAAA,GAAAC,EARiB,GAAX,CAAMC,SAOV,GAAAL,EAAAG,GAAA,MAAA;AAAA,OAP6CJ,EAAA,GAAAC,EAAAG,GAAA,MAAAC,EAAA,GAAA,CAAAE,MAC5CC,EAAgB,OAAA;AAAA,QAAE,KAAK,SAAAF,KAAAC;AAAA,QAAA,OAAA;AAAA,QAA+J,OAAAE,EAAA;AAAA,UAA6M,YAAAf,EAAA,eAAA,YAAA;AAAA,UAAA,MAAA,QAAAa,IAAA;AAAA;;;;WAsBnZ,GAAA,EAAA,KAAAG,EAAA,IAAA,EAAA;AAAA;;;;"}