{"version":3,"file":"vue3-components2.js","sources":["../../../../src/components/Carousel/Carousel.vue"],"sourcesContent":["<template>\n    <div class=\"carousel\" :class=\"{ disabled }\" ref=\"root$\">\n        <div v-for=\"(entry, index) in entries\" :ref=\"(el) => { refs$[entry] = el as HTMLElement }\" :key=\"index\"\n            :class=\"{ selected: effectiveSelected === entry }\"\n            @click=\"!disabled && updateSelection(entry)\"\n            @focusin=\"!disabled && updateSelection(entry)\">\n            <slot :name=\"entry\"></slot>\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, nextTick, onMounted, onUnmounted, ref, watch } from 'vue';\nimport { Tweenable } from '@nimiq/utils';\n\nexport enum CarouselEvent {\n    SELECT = 'select',\n}\n\nexport default defineComponent({\n    name: 'Carousel',\n    emits: Object.values(CarouselEvent),\n    props: {\n        entries: {\n            type: Array as () => string[],\n            default: () => [],\n            validator: (entries: any) => Array.isArray(entries)\n                && entries.length > 0\n                && !entries.some((entry) => typeof entry !== 'string'),\n        },\n        selected: String,\n        entryMargin: {\n            type: Number,\n            default: 16,\n        },\n        animationDuration: { // in ms\n            type: Number,\n            default: 1000,\n        },\n        hideBackgroundEntries: {\n            type: Boolean,\n            default: false,\n        },\n        disabled: {\n            type: Boolean,\n            default: false,\n        },\n    },\n    setup(props, context) {\n        const root$ = ref<HTMLDivElement | null>(null);\n        // The entry refs are arrays with a single element because of v-for\n        const refs$ = ref<{ [ref: string]: HTMLElement }>({});\n\n        const effectiveSelected = ref('');\n        const requestAnimationFrameId = ref<number | null>(null);\n\n        const radius: Tweenable = new Tweenable();\n        const rotations: Map<string, Tweenable> = new Map(); // map entry -> rotation\n\n        const hasDummyPosition = computed(() =>{\n            // add dummy to avoid that second entry is hidden exactly behind selected item on opposite side of circle.\n            return props.entries.length <= 2;\n        });\n\n        const totalPositionCount = computed(() => {\n            return props.entries.length + (hasDummyPosition.value ? 1 : 0);\n        });\n\n        onMounted(async () => {\n            // this.onKeydown = this.onKeydown.bind(this); // TODO: is this still necessary?\n            document.addEventListener('keydown', onKeydown);\n            // trigger these manually instead of via immediate watcher to avoid animating on first render\n            await updateDimensions(false);\n            updateSelection(props.selected);\n            updateRotations(false);\n        });\n\n        onUnmounted(() => {\n            document.removeEventListener('keydown', onKeydown);\n            if (requestAnimationFrameId.value === null) return;\n            cancelAnimationFrame(requestAnimationFrameId.value);\n        });\n\n        watch(() => props.entryMargin, updateDimensions);\n        async function updateDimensions(newWatcherValueOrTween: number | boolean = true) {\n            const tween = typeof newWatcherValueOrTween === 'boolean' ? newWatcherValueOrTween : true;\n            await nextTick(); // let Vue render new entries\n            let largestHeight = 0;\n            let largestMinDistance = 0;\n            for (let i = 0; i < props.entries.length; ++i) {\n                const el1 = refs$.value[props.entries[i]];\n                const el2 = refs$.value[props.entries[(i + 1) % props.entries.length]];\n                largestHeight = Math.max(largestHeight, el1.offsetHeight);\n                const minDistance = el1.offsetWidth / 2 + el2.offsetWidth / 2 + props.entryMargin;\n                largestMinDistance = Math.max(largestMinDistance, minDistance);\n            }\n            // Choose radius big enough such that two items can be rendered side by side without overlapping.\n            // Calculate on a right triangle formed by radius, half distance and perpendicular from center point\n            // to distance line.\n            const centerAngle = 2 * Math.PI / totalPositionCount.value / 2; // angle at circle center point\n            const newRadius = (largestMinDistance / 2) / Math.sin(centerAngle);\n            radius.tweenTo(newRadius, tween ? props.animationDuration : 0);\n            if (root$.value) root$.value.style.minHeight = `${largestHeight}px`;\n            rerender();\n        }\n\n        watch(() => props.entries, onEntriesChange);\n        async function onEntriesChange() {\n            await updateDimensions();\n            updateSelection(effectiveSelected.value); // re-validate\n            updateRotations();\n        }\n\n        watch(() => props.selected, updateSelection);\n        function updateSelection(newSelection: string | undefined) {\n            if (newSelection === undefined) return;\n\n            const oldSelection = effectiveSelected.value;\n            const isNewSelectionValid = props.entries.includes(newSelection);\n            const isOldSelectionValid = props.entries.includes(oldSelection);\n\n            if (isNewSelectionValid) {\n                effectiveSelected.value = newSelection;\n            } else if (!isOldSelectionValid) {\n                effectiveSelected.value = props.entries[0];\n            } // else keep the old selection\n\n            if (effectiveSelected.value !== oldSelection) {\n                context.emit(CarouselEvent.SELECT, effectiveSelected.value);\n            }\n        }\n\n        watch(effectiveSelected, updateRotations);\n        watch(() => props.disabled, updateRotations);\n        function updateRotations(newWatcherValueOrTween: string | boolean = true, previousWatcherValue?: string | boolean) {\n            const tween = typeof newWatcherValueOrTween === 'boolean' && typeof previousWatcherValue === 'undefined'\n                ? newWatcherValueOrTween // specified whether to tween\n                : true; // did not specify whether to tween or method was called as a watcher (default to true)\n            // clean up removed entries\n\n            for (const entry of rotations.keys()) {\n                if (props.entries.includes(entry)) continue;\n                rotations.delete(entry);\n            }\n            // update rotations\n            for (const entry of props.entries) {\n                const rotation = rotations.get(entry) || new Tweenable();\n                const tweenTime = tween ? props.animationDuration : 0;\n                rotation.tweenTo(calculateTargetRotation(entry, rotation.currentValue), tweenTime);\n                rotations.set(entry, rotation);\n            }\n            rerender();\n        }\n\n        /**\n         * @param entry\n         * @param currentRotation - Rotation in radians\n         * @private\n         */\n        function calculateTargetRotation(entry: string, currentRotation: number): number {\n            if (props.disabled && entry !== effectiveSelected.value) {\n                // hide not selected entries at other end of circle\n                return currentRotation + calculateRotationInClosestDirection(currentRotation, Math.PI);\n            }\n            const stepSize = 2 * Math.PI / totalPositionCount.value;\n            const entryIndex = props.entries.indexOf(entry);\n            const selectedIndex = props.entries.indexOf(effectiveSelected.value);\n            let offset = entryIndex - selectedIndex;\n            if (hasDummyPosition.value && offset > totalPositionCount.value / 2) {\n                // skip dummy position\n                offset += 1;\n            }\n            return currentRotation + calculateRotationInClosestDirection(currentRotation, offset * stepSize);\n        }\n\n        // @Watch('hideBackgroundEntries')\n        watch(() => props.hideBackgroundEntries, rerender);\n        function rerender() {\n            if (requestAnimationFrameId.value !== null) return;\n            requestAnimationFrameId.value = requestAnimationFrame(() => {\n                const zCoordinatesForEntries: Array<[string, number]> = [];\n                let finished = radius.finished;\n                for (const [entry, rotation] of rotations) {\n                    const currentRotation = rotation.currentValue;\n                    const currentRadius = radius.currentValue;\n                    const x = Math.sin(currentRotation) * currentRadius;\n                    const z = Math.cos(currentRotation) * currentRadius - currentRadius;\n                    const el = refs$.value[entry];\n                    el.style.transform = `translate3d(calc(${x}px - 50%),-50%,${z}px)`;\n                    el.style.display = shouldHide(entry) ? 'none' : '';\n                    zCoordinatesForEntries.push([entry, z]);\n                    finished = finished && rotation.finished;\n                }\n\n                // Note that instead of setting z-index manually, we could use transform-style: preserve-3d to order\n                // automatically by z coordinate. But unfortunately, this makes the entries not clickable anymore.\n                zCoordinatesForEntries.sort(([, z1], [, z2]) => z1 - z2);\n                for (let i = 0; i < zCoordinatesForEntries.length; ++i) {\n                    const el = refs$.value[zCoordinatesForEntries[i][0]];\n                    el.style.zIndex = `${i}`;\n                }\n\n                requestAnimationFrameId.value = null;\n                if (!finished) rerender();\n            });\n        }\n\n        function calculateRotationInClosestDirection(fromAngle: number, toAngle: number): number {\n            // angle offset modulo full rotations\n            const rotation = (toAngle - fromAngle) % (2 * Math.PI);\n            // determine rotation in opposite direction (subtracting or adding a full circle depending on direction (sign))\n            const rotationOppositeDirection = rotation - Math.sign(rotation) * 2 * Math.PI;\n            if (Math.abs(Math.abs(rotation) - Math.abs(rotationOppositeDirection)) < 1e-10) {\n                // in case of ambiguity chose a default direction\n                return Math.min(rotation, rotationOppositeDirection);\n            } else if (Math.abs(rotation) < Math.abs(rotationOppositeDirection)) {\n                return rotation;\n            } else {\n                return rotationOppositeDirection;\n            }\n        }\n\n        function shouldHide(entry: string): boolean {\n            const rotation = rotations.get(entry);\n\n            if (!rotation || (!props.disabled && !props.hideBackgroundEntries)) return false;\n\n            const absoluteRotation = Math.abs(calculateRotationInClosestDirection(0, rotation.currentValue));\n\n            if (props.disabled) {\n                // Hide disabled elements once they reached the opposite end of the circle, also to avoid that they are\n                // still reachable via tab. While they're animating to get there, display them even when they're in the\n                // back part of the circle.\n                return Math.abs(absoluteRotation - Math.PI) < 1e-10;\n            } else if (props.hideBackgroundEntries) {\n                // Hide entries in the back part of the circle as these will not be visible behind the front entries\n                const stepSize = 2 * Math.PI / totalPositionCount.value;\n                const threshold = Math.PI / 2 + stepSize / (totalPositionCount.value - 1); // just a heuristic but works ok\n                return absoluteRotation > threshold;\n            }\n            return false; // TODO/FIXME: the function needs to always return a boolean, so added this but not sure if it's correct\n        }\n\n        function onKeydown(event: KeyboardEvent) {\n            const target = event.target as HTMLElement;\n            if (props.disabled\n                || target.tagName === 'INPUT'\n                || target.tagName === 'TEXTAREA'\n                || rotations.values().next().value.progress < .5 // block if previous change not animated far enough\n            ) return;\n            const currentIndex = props.entries.indexOf(effectiveSelected.value);\n            let newIndex;\n            if (event.key === 'ArrowLeft') {\n                newIndex = (currentIndex - 1 + props.entries.length) % props.entries.length;\n            } else if (event.key === 'ArrowRight') {\n                newIndex = (currentIndex + 1) % props.entries.length;\n            } else {\n                return;\n            }\n            updateSelection(props.entries[newIndex]);\n        }\n\n        return {\n            root$,\n            refs$,\n            effectiveSelected,\n            updateSelection,\n        };\n    }\n})\n</script>\n\n<style scoped>\n    .carousel {\n        position: relative;\n        padding: 4rem;\n        box-sizing: content-box;\n        perspective: 1500px;\n        /* perspective-origin: center 150%; */ /* useful for debugging */\n    }\n\n    .carousel > * {\n        position: absolute;\n        left: 50%;\n        top: 50%;\n    }\n\n    .carousel:not(.disabled) > :not(.selected) {\n        cursor: pointer;\n    }\n\n    .carousel > :not(.selected):deep(*) {\n        pointer-events: none !important;\n    }\n</style>\n"],"names":["CarouselEvent","_sfc_main","defineComponent","entries","entry","props","context","root$","ref","refs$","effectiveSelected","requestAnimationFrameId","radius","Tweenable","rotations","hasDummyPosition","computed","totalPositionCount","onMounted","onKeydown","updateDimensions","updateSelection","updateRotations","onUnmounted","watch","newWatcherValueOrTween","tween","nextTick","largestHeight","largestMinDistance","i","el1","el2","minDistance","centerAngle","newRadius","rerender","onEntriesChange","newSelection","oldSelection","isNewSelectionValid","isOldSelectionValid","previousWatcherValue","rotation","tweenTime","calculateTargetRotation","currentRotation","calculateRotationInClosestDirection","stepSize","entryIndex","selectedIndex","offset","zCoordinatesForEntries","finished","currentRadius","x","z","el","shouldHide","z1","z2","fromAngle","toAngle","rotationOppositeDirection","absoluteRotation","threshold","event","target","currentIndex","newIndex"],"mappings":";;AAeY,IAAAA,sBAAAA,OACRA,EAAA,SAAS,UADDA,IAAAA,KAAA,CAAA,CAAA;AAIZ,MAAAC,IAAeC,EAAgB;AAAA,EAC3B,MAAM;AAAA,EACN,OAAO,OAAO,OAAOF,CAAa;AAAA,EAClC,OAAO;AAAA,IACH,SAAS;AAAA,MACL,MAAM;AAAA,MACN,SAAS,MAAM,CAAC;AAAA,MAChB,WAAW,CAACG,MAAiB,MAAM,QAAQA,CAAO,KAC3CA,EAAQ,SAAS,KACjB,CAACA,EAAQ,KAAK,CAACC,MAAU,OAAOA,KAAU,QAAQ;AAAA,IAC7D;AAAA,IACA,UAAU;AAAA,IACV,aAAa;AAAA,MACT,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,mBAAmB;AAAA,MACf,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,uBAAuB;AAAA,MACnB,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,UAAU;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,EACJ;AAAA,EACA,MAAMC,GAAOC,GAAS;AACZ,UAAAC,IAAQC,EAA2B,IAAI,GAEvCC,IAAQD,EAAoC,CAAA,CAAE,GAE9CE,IAAoBF,EAAI,EAAE,GAC1BG,IAA0BH,EAAmB,IAAI,GAEjDI,IAAoB,IAAIC,KACxBC,wBAAwC,OAExCC,IAAmBC,EAAS,MAEvBX,EAAM,QAAQ,UAAU,CAClC,GAEKY,IAAqBD,EAAS,MACzBX,EAAM,QAAQ,UAAUU,EAAiB,QAAQ,IAAI,EAC/D;AAED,IAAAG,EAAU,YAAY;AAET,eAAA,iBAAiB,WAAWC,CAAS,GAE9C,MAAMC,EAAiB,EAAK,GAC5BC,EAAgBhB,EAAM,QAAQ,GAC9BiB,EAAgB,EAAK;AAAA,IAAA,CACxB,GAEDC,EAAY,MAAM;AAEd,MADS,SAAA,oBAAoB,WAAWJ,CAAS,GAC7CR,EAAwB,UAAU,QACtC,qBAAqBA,EAAwB,KAAK;AAAA,IAAA,CACrD,GAEKa,EAAA,MAAMnB,EAAM,aAAae,CAAgB;AAChC,mBAAAA,EAAiBK,IAA2C,IAAM;AAC7E,YAAMC,IAAQ,OAAOD,KAA2B,YAAYA,IAAyB;AACrF,YAAME,EAAS;AACf,UAAIC,IAAgB,GAChBC,IAAqB;AACzB,eAASC,IAAI,GAAGA,IAAIzB,EAAM,QAAQ,QAAQ,EAAEyB,GAAG;AAC3C,cAAMC,IAAMtB,EAAM,MAAMJ,EAAM,QAAQyB,KAChCE,IAAMvB,EAAM,MAAMJ,EAAM,SAASyB,IAAI,KAAKzB,EAAM,QAAQ;AAC9D,QAAAuB,IAAgB,KAAK,IAAIA,GAAeG,EAAI,YAAY;AACxD,cAAME,IAAcF,EAAI,cAAc,IAAIC,EAAI,cAAc,IAAI3B,EAAM;AACjD,QAAAwB,IAAA,KAAK,IAAIA,GAAoBI,CAAW;AAAA,MACjE;AAIA,YAAMC,IAAc,IAAI,KAAK,KAAKjB,EAAmB,QAAQ,GACvDkB,IAAaN,IAAqB,IAAK,KAAK,IAAIK,CAAW;AACjE,MAAAtB,EAAO,QAAQuB,GAAWT,IAAQrB,EAAM,oBAAoB,CAAC,GACzDE,EAAM,UAAaA,EAAA,MAAM,MAAM,YAAY,GAAGqB,QACzCQ;IACb;AAEM,IAAAZ,EAAA,MAAMnB,EAAM,SAASgC,CAAe;AAC1C,mBAAeA,IAAkB;AAC7B,YAAMjB,EAAiB,GACvBC,EAAgBX,EAAkB,KAAK,GACvBY;IACpB;AAEM,IAAAE,EAAA,MAAMnB,EAAM,UAAUgB,CAAe;AAC3C,aAASA,EAAgBiB,GAAkC;AACvD,UAAIA,MAAiB;AAAW;AAEhC,YAAMC,IAAe7B,EAAkB,OACjC8B,IAAsBnC,EAAM,QAAQ,SAASiC,CAAY,GACzDG,IAAsBpC,EAAM,QAAQ,SAASkC,CAAY;AAE/D,MAAIC,IACA9B,EAAkB,QAAQ4B,IAClBG,MACU/B,EAAA,QAAQL,EAAM,QAAQ,KAGxCK,EAAkB,UAAU6B,KACpBjC,EAAA,KAAK,UAAsBI,EAAkB,KAAK;AAAA,IAElE;AAEA,IAAAc,EAAMd,GAAmBY,CAAe,GAClCE,EAAA,MAAMnB,EAAM,UAAUiB,CAAe;AAClC,aAAAA,EAAgBG,IAA2C,IAAMiB,GAAyC;AAC/G,YAAMhB,IAAQ,OAAOD,KAA2B,aAAa,OAAOiB,IAAyB,MACvFjB,IACA;AAGK,iBAAArB,KAASU,EAAU;AACtB,QAAAT,EAAM,QAAQ,SAASD,CAAK,KAChCU,EAAU,OAAOV,CAAK;AAGf,iBAAAA,KAASC,EAAM,SAAS;AAC/B,cAAMsC,IAAW7B,EAAU,IAAIV,CAAK,KAAK,IAAIS,KACvC+B,IAAYlB,IAAQrB,EAAM,oBAAoB;AACpD,QAAAsC,EAAS,QAAQE,EAAwBzC,GAAOuC,EAAS,YAAY,GAAGC,CAAS,GACvE9B,EAAA,IAAIV,GAAOuC,CAAQ;AAAA,MACjC;AACS,MAAAP;IACb;AAOS,aAAAS,EAAwBzC,GAAe0C,GAAiC;AAC7E,UAAIzC,EAAM,YAAYD,MAAUM,EAAkB;AAE9C,eAAOoC,IAAkBC,EAAoCD,GAAiB,KAAK,EAAE;AAEzF,YAAME,IAAW,IAAI,KAAK,KAAK/B,EAAmB,OAC5CgC,IAAa5C,EAAM,QAAQ,QAAQD,CAAK,GACxC8C,IAAgB7C,EAAM,QAAQ,QAAQK,EAAkB,KAAK;AACnE,UAAIyC,IAASF,IAAaC;AAC1B,aAAInC,EAAiB,SAASoC,IAASlC,EAAmB,QAAQ,MAEpDkC,KAAA,IAEPL,IAAkBC,EAAoCD,GAAiBK,IAASH,CAAQ;AAAA,IACnG;AAGM,IAAAxB,EAAA,MAAMnB,EAAM,uBAAuB+B,CAAQ;AACjD,aAASA,IAAW;AAChB,MAAIzB,EAAwB,UAAU,SACdA,EAAA,QAAQ,sBAAsB,MAAM;AACxD,cAAMyC,IAAkD,CAAA;AACxD,YAAIC,IAAWzC,EAAO;AACtB,mBAAW,CAACR,GAAOuC,CAAQ,KAAK7B,GAAW;AACvC,gBAAMgC,IAAkBH,EAAS,cAC3BW,IAAgB1C,EAAO,cACvB2C,IAAI,KAAK,IAAIT,CAAe,IAAIQ,GAChCE,IAAI,KAAK,IAAIV,CAAe,IAAIQ,IAAgBA,GAChDG,IAAKhD,EAAM,MAAML;AACpB,UAAAqD,EAAA,MAAM,YAAY,oBAAoBF,mBAAmBC,QAC5DC,EAAG,MAAM,UAAUC,EAAWtD,CAAK,IAAI,SAAS,IAChDgD,EAAuB,KAAK,CAAChD,GAAOoD,CAAC,CAAC,GACtCH,IAAWA,KAAYV,EAAS;AAAA,QACpC;AAIuB,QAAAS,EAAA,KAAK,CAAC,GAAGO,CAAE,GAAG,CAAA,EAAGC,CAAE,MAAMD,IAAKC,CAAE;AACvD,iBAAS9B,IAAI,GAAGA,IAAIsB,EAAuB,QAAQ,EAAEtB,GAAG;AACpD,gBAAM2B,IAAKhD,EAAM,MAAM2C,EAAuBtB,GAAG;AAC9C,UAAA2B,EAAA,MAAM,SAAS,GAAG3B;AAAA,QACzB;AAEA,QAAAnB,EAAwB,QAAQ,MAC3B0C,KAAmBjB;MAAA,CAC3B;AAAA,IACL;AAES,aAAAW,EAAoCc,GAAmBC,GAAyB;AAErF,YAAMnB,KAAYmB,IAAUD,MAAc,IAAI,KAAK,KAE7CE,IAA4BpB,IAAW,KAAK,KAAKA,CAAQ,IAAI,IAAI,KAAK;AACxE,aAAA,KAAK,IAAI,KAAK,IAAIA,CAAQ,IAAI,KAAK,IAAIoB,CAAyB,CAAC,IAAI,QAE9D,KAAK,IAAIpB,GAAUoB,CAAyB,IAC5C,KAAK,IAAIpB,CAAQ,IAAI,KAAK,IAAIoB,CAAyB,IACvDpB,IAEAoB;AAAA,IAEf;AAEA,aAASL,EAAWtD,GAAwB;AAClC,YAAAuC,IAAW7B,EAAU,IAAIV,CAAK;AAEpC,UAAI,CAACuC,KAAa,CAACtC,EAAM,YAAY,CAACA,EAAM;AAA+B,eAAA;AAE3E,YAAM2D,IAAmB,KAAK,IAAIjB,EAAoC,GAAGJ,EAAS,YAAY,CAAC;AAE/F,UAAItC,EAAM;AAIN,eAAO,KAAK,IAAI2D,IAAmB,KAAK,EAAE,IAAI;AAClD,UAAW3D,EAAM,uBAAuB;AAEpC,cAAM2C,IAAW,IAAI,KAAK,KAAK/B,EAAmB,OAC5CgD,IAAY,KAAK,KAAK,IAAIjB,KAAY/B,EAAmB,QAAQ;AACvE,eAAO+C,IAAmBC;AAAA,MAC9B;AACO,aAAA;AAAA,IACX;AAEA,aAAS9C,EAAU+C,GAAsB;AACrC,YAAMC,IAASD,EAAM;AACrB,UAAI7D,EAAM,YACH8D,EAAO,YAAY,WACnBA,EAAO,YAAY,cACnBrD,EAAU,OAAO,EAAE,KAAK,EAAE,MAAM,WAAW;AAChD;AACF,YAAMsD,IAAe/D,EAAM,QAAQ,QAAQK,EAAkB,KAAK;AAC9D,UAAA2D;AACA,UAAAH,EAAM,QAAQ;AACd,QAAAG,KAAYD,IAAe,IAAI/D,EAAM,QAAQ,UAAUA,EAAM,QAAQ;AAAA,eAC9D6D,EAAM,QAAQ;AACT,QAAAG,KAAAD,IAAe,KAAK/D,EAAM,QAAQ;AAAA;AAE9C;AAEY,MAAAgB,EAAAhB,EAAM,QAAQgE,EAAS;AAAA,IAC3C;AAEO,WAAA;AAAA,MACH,OAAA9D;AAAA,MACA,OAAAE;AAAA,MACA,mBAAAC;AAAA,MACA,iBAAAW;AAAA,IAAA;AAAA,EAER;AACJ,CAAC;"}