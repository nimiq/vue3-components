{"version":3,"file":"vue3-components.js","sources":["../../../../src/components/Carousel/Carousel.vue"],"sourcesContent":["<template>\n    <div class=\"carousel\" :class=\"{ disabled }\" ref=\"root$\">\n        <div v-for=\"(entry, index) in entries\" :ref=\"(el) => { refs$[entry] = el as HTMLElement }\" :key=\"index\"\n            :class=\"{ selected: effectiveSelected === entry }\"\n            @click=\"!disabled && updateSelection(entry)\"\n            @focusin=\"!disabled && updateSelection(entry)\">\n            <slot :name=\"entry\"></slot>\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, nextTick, onMounted, onUnmounted, ref, watch } from 'vue';\nimport { Tweenable } from '@nimiq/utils';\n\nexport enum CarouselEvent {\n    SELECT = 'select',\n}\n\nexport default defineComponent({\n    name: 'Carousel',\n    emits: Object.values(CarouselEvent),\n    props: {\n        entries: {\n            type: Array as () => string[],\n            default: () => [],\n            validator: (entries: any) => Array.isArray(entries)\n                && entries.length > 0\n                && !entries.some((entry) => typeof entry !== 'string'),\n        },\n        selected: String,\n        entryMargin: {\n            type: Number,\n            default: 16,\n        },\n        animationDuration: { // in ms\n            type: Number,\n            default: 1000,\n        },\n        hideBackgroundEntries: {\n            type: Boolean,\n            default: false,\n        },\n        disabled: {\n            type: Boolean,\n            default: false,\n        },\n    },\n    setup(props, context) {\n        const root$ = ref<HTMLDivElement | null>(null);\n        // The entry refs are arrays with a single element because of v-for\n        const refs$ = ref<{ [ref: string]: HTMLElement }>({});\n\n        const effectiveSelected = ref('');\n        const requestAnimationFrameId = ref<number | null>(null);\n\n        const radius: Tweenable = new Tweenable();\n        const rotations: Map<string, Tweenable> = new Map(); // map entry -> rotation\n\n        const hasDummyPosition = computed(() =>{\n            // add dummy to avoid that second entry is hidden exactly behind selected item on opposite side of circle.\n            return props.entries.length <= 2;\n        });\n\n        const totalPositionCount = computed(() => {\n            return props.entries.length + (hasDummyPosition.value ? 1 : 0);\n        });\n\n        onMounted(async () => {\n            // this.onKeydown = this.onKeydown.bind(this); // TODO: is this still necessary?\n            document.addEventListener('keydown', onKeydown);\n            // trigger these manually instead of via immediate watcher to avoid animating on first render\n            await updateDimensions(false);\n            updateSelection(props.selected);\n            updateRotations(false);\n        });\n\n        onUnmounted(() => {\n            document.removeEventListener('keydown', onKeydown);\n            if (requestAnimationFrameId.value === null) return;\n            cancelAnimationFrame(requestAnimationFrameId.value);\n        });\n\n        watch(() => props.entryMargin, updateDimensions);\n        async function updateDimensions(newWatcherValueOrTween: number | boolean = true) {\n            const tween = typeof newWatcherValueOrTween === 'boolean' ? newWatcherValueOrTween : true;\n            await nextTick(); // let Vue render new entries\n            let largestHeight = 0;\n            let largestMinDistance = 0;\n            for (let i = 0; i < props.entries.length; ++i) {\n                const el1 = refs$.value[props.entries[i]];\n                const el2 = refs$.value[props.entries[(i + 1) % props.entries.length]];\n                largestHeight = Math.max(largestHeight, el1.offsetHeight);\n                const minDistance = el1.offsetWidth / 2 + el2.offsetWidth / 2 + props.entryMargin;\n                largestMinDistance = Math.max(largestMinDistance, minDistance);\n            }\n            // Choose radius big enough such that two items can be rendered side by side without overlapping.\n            // Calculate on a right triangle formed by radius, half distance and perpendicular from center point\n            // to distance line.\n            const centerAngle = 2 * Math.PI / totalPositionCount.value / 2; // angle at circle center point\n            const newRadius = (largestMinDistance / 2) / Math.sin(centerAngle);\n            radius.tweenTo(newRadius, tween ? props.animationDuration : 0);\n            if (root$.value) root$.value.style.minHeight = `${largestHeight}px`;\n            rerender();\n        }\n\n        watch(() => props.entries, onEntriesChange);\n        async function onEntriesChange() {\n            await updateDimensions();\n            updateSelection(effectiveSelected.value); // re-validate\n            updateRotations();\n        }\n\n        watch(() => props.selected, updateSelection);\n        function updateSelection(newSelection: string | undefined) {\n            if (newSelection === undefined) return;\n\n            const oldSelection = effectiveSelected.value;\n            const isNewSelectionValid = props.entries.includes(newSelection);\n            const isOldSelectionValid = props.entries.includes(oldSelection);\n\n            if (isNewSelectionValid) {\n                effectiveSelected.value = newSelection;\n            } else if (!isOldSelectionValid) {\n                effectiveSelected.value = props.entries[0];\n            } // else keep the old selection\n\n            if (effectiveSelected.value !== oldSelection) {\n                context.emit(CarouselEvent.SELECT, effectiveSelected.value);\n            }\n        }\n\n        watch(effectiveSelected, updateRotations);\n        watch(() => props.disabled, updateRotations);\n        function updateRotations(newWatcherValueOrTween: string | boolean = true, previousWatcherValue?: string | boolean) {\n            const tween = typeof newWatcherValueOrTween === 'boolean' && typeof previousWatcherValue === 'undefined'\n                ? newWatcherValueOrTween // specified whether to tween\n                : true; // did not specify whether to tween or method was called as a watcher (default to true)\n            // clean up removed entries\n\n            for (const entry of rotations.keys()) {\n                if (props.entries.includes(entry)) continue;\n                rotations.delete(entry);\n            }\n            // update rotations\n            for (const entry of props.entries) {\n                const rotation = rotations.get(entry) || new Tweenable();\n                const tweenTime = tween ? props.animationDuration : 0;\n                rotation.tweenTo(calculateTargetRotation(entry, rotation.currentValue), tweenTime);\n                rotations.set(entry, rotation);\n            }\n            rerender();\n        }\n\n        /**\n         * @param entry\n         * @param currentRotation - Rotation in radians\n         * @private\n         */\n        function calculateTargetRotation(entry: string, currentRotation: number): number {\n            if (props.disabled && entry !== effectiveSelected.value) {\n                // hide not selected entries at other end of circle\n                return currentRotation + calculateRotationInClosestDirection(currentRotation, Math.PI);\n            }\n            const stepSize = 2 * Math.PI / totalPositionCount.value;\n            const entryIndex = props.entries.indexOf(entry);\n            const selectedIndex = props.entries.indexOf(effectiveSelected.value);\n            let offset = entryIndex - selectedIndex;\n            if (hasDummyPosition.value && offset > totalPositionCount.value / 2) {\n                // skip dummy position\n                offset += 1;\n            }\n            return currentRotation + calculateRotationInClosestDirection(currentRotation, offset * stepSize);\n        }\n\n        // @Watch('hideBackgroundEntries')\n        watch(() => props.hideBackgroundEntries, rerender);\n        function rerender() {\n            if (requestAnimationFrameId.value !== null) return;\n            requestAnimationFrameId.value = requestAnimationFrame(() => {\n                const zCoordinatesForEntries: Array<[string, number]> = [];\n                let finished = radius.finished;\n                for (const [entry, rotation] of rotations) {\n                    const currentRotation = rotation.currentValue;\n                    const currentRadius = radius.currentValue;\n                    const x = Math.sin(currentRotation) * currentRadius;\n                    const z = Math.cos(currentRotation) * currentRadius - currentRadius;\n                    const el = refs$.value[entry];\n                    el.style.transform = `translate3d(calc(${x}px - 50%),-50%,${z}px)`;\n                    el.style.display = shouldHide(entry) ? 'none' : '';\n                    zCoordinatesForEntries.push([entry, z]);\n                    finished = finished && rotation.finished;\n                }\n\n                // Note that instead of setting z-index manually, we could use transform-style: preserve-3d to order\n                // automatically by z coordinate. But unfortunately, this makes the entries not clickable anymore.\n                zCoordinatesForEntries.sort(([, z1], [, z2]) => z1 - z2);\n                for (let i = 0; i < zCoordinatesForEntries.length; ++i) {\n                    const el = refs$.value[zCoordinatesForEntries[i][0]];\n                    el.style.zIndex = `${i}`;\n                }\n\n                requestAnimationFrameId.value = null;\n                if (!finished) rerender();\n            });\n        }\n\n        function calculateRotationInClosestDirection(fromAngle: number, toAngle: number): number {\n            // angle offset modulo full rotations\n            const rotation = (toAngle - fromAngle) % (2 * Math.PI);\n            // determine rotation in opposite direction (subtracting or adding a full circle depending on direction (sign))\n            const rotationOppositeDirection = rotation - Math.sign(rotation) * 2 * Math.PI;\n            if (Math.abs(Math.abs(rotation) - Math.abs(rotationOppositeDirection)) < 1e-10) {\n                // in case of ambiguity chose a default direction\n                return Math.min(rotation, rotationOppositeDirection);\n            } else if (Math.abs(rotation) < Math.abs(rotationOppositeDirection)) {\n                return rotation;\n            } else {\n                return rotationOppositeDirection;\n            }\n        }\n\n        function shouldHide(entry: string): boolean {\n            const rotation = rotations.get(entry);\n\n            if (!rotation || (!props.disabled && !props.hideBackgroundEntries)) return false;\n\n            const absoluteRotation = Math.abs(calculateRotationInClosestDirection(0, rotation.currentValue));\n\n            if (props.disabled) {\n                // Hide disabled elements once they reached the opposite end of the circle, also to avoid that they are\n                // still reachable via tab. While they're animating to get there, display them even when they're in the\n                // back part of the circle.\n                return Math.abs(absoluteRotation - Math.PI) < 1e-10;\n            } else if (props.hideBackgroundEntries) {\n                // Hide entries in the back part of the circle as these will not be visible behind the front entries\n                const stepSize = 2 * Math.PI / totalPositionCount.value;\n                const threshold = Math.PI / 2 + stepSize / (totalPositionCount.value - 1); // just a heuristic but works ok\n                return absoluteRotation > threshold;\n            }\n            return false; // TODO/FIXME: the function needs to always return a boolean, so added this but not sure if it's correct\n        }\n\n        function onKeydown(event: KeyboardEvent) {\n            const target = event.target as HTMLElement;\n            if (props.disabled\n                || target.tagName === 'INPUT'\n                || target.tagName === 'TEXTAREA'\n                || rotations.values().next().value.progress < .5 // block if previous change not animated far enough\n            ) return;\n            const currentIndex = props.entries.indexOf(effectiveSelected.value);\n            let newIndex;\n            if (event.key === 'ArrowLeft') {\n                newIndex = (currentIndex - 1 + props.entries.length) % props.entries.length;\n            } else if (event.key === 'ArrowRight') {\n                newIndex = (currentIndex + 1) % props.entries.length;\n            } else {\n                return;\n            }\n            updateSelection(props.entries[newIndex]);\n        }\n\n        return {\n            root$,\n            refs$,\n            effectiveSelected,\n            updateSelection,\n        };\n    }\n})\n</script>\n\n<style scoped>\n    .carousel {\n        position: relative;\n        padding: 4rem;\n        box-sizing: content-box;\n        perspective: 1500px;\n        /* perspective-origin: center 150%; */ /* useful for debugging */\n    }\n\n    .carousel > * {\n        position: absolute;\n        left: 50%;\n        top: 50%;\n    }\n\n    .carousel:not(.disabled) > :not(.selected) {\n        cursor: pointer;\n    }\n\n    .carousel > :not(.selected):deep(*) {\n        pointer-events: none !important;\n    }\n</style>\n"],"names":["_sfc_render","_ctx","_cache","$props","$setup","$options","_openBlock","_createElementBlock","_normalizeClass","el","entry","index","$event"],"mappings":";;;;;;SACcA,EAACC,GAAAC,GAAAC,GAAUC,MAAWC,GAAQ;SAAQC,EAAO,GAAAC,EAAA,OAAA;AAAA,IAAA,OAAAC,EAAA,CAAA,YAAA,EAAA,UAAAP,EAAA,SAAA,CAAA,CAAA;AAAA;;+CACLK,EAAA,GAA0BC,EAAA,OAAA;AAAA,MAAoB,SAAK;AAAA,MAC5F,KAAK,CAAAE,MAAA;AAAc,QAAAR,EAAA,MAAAS,KAAAD;AAAA,MAAA;AAAA,MACnB,KAAAE;AAAA,MACA,OAAAH,EAAU,EAAY,UAAAP,EAAA,sBAAgBS,GAAK;AAAA,MAAA,SAAA,CAAAE,MAAA,CAAAX,EAAA,YAAAA,EAAA,gBAAAS,CAAA;AAAA,MAC5C,WAAA,CAAAE,MAA2B,GAAd,YAAKX,EAAA,gBAAAS,CAAA;AAAA,IAAA,GAAA;AAAA;;;;;"}