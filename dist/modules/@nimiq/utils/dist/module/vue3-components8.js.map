{"version":3,"file":"vue3-components8.js","sources":["../../../../../../node_modules/@nimiq/utils/dist/module/Utf8Tools.js"],"sourcesContent":["/* eslint-disable no-bitwise, no-plusplus, eqeqeq */\n/**\n * Sources:\n *\n * Conversion functions taken from\n * https://github.com/google/closure-library/blob/master/closure/goog/crypt/crypt.js\n *\n * UTF-8 validitiy limit values from\n * https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/\n */\nclass Utf8Tools {\n    static stringToUtf8ByteArray(str) {\n        if (typeof TextEncoder !== 'undefined') {\n            const encoder = new TextEncoder(); // utf-8 is the default\n            return encoder.encode(str);\n        }\n        // Fallback for unsupported TextEncoder\n        const out = [];\n        let p = 0;\n        for (let i = 0; i < str.length; i++) {\n            let c = str.charCodeAt(i);\n            if (c < 128) {\n                out[p++] = c;\n            }\n            else if (c < 2048) {\n                out[p++] = (c >> 6) | 192;\n                out[p++] = (c & 63) | 128;\n            }\n            else if (((c & 0xFC00) == 0xD800) && (i + 1) < str.length\n                && ((str.charCodeAt(i + 1) & 0xFC00) == 0xDC00)) {\n                // Surrogate Pair\n                c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF);\n                out[p++] = (c >> 18) | 240;\n                out[p++] = ((c >> 12) & 63) | 128;\n                out[p++] = ((c >> 6) & 63) | 128;\n                out[p++] = (c & 63) | 128;\n            }\n            else {\n                out[p++] = (c >> 12) | 224;\n                out[p++] = ((c >> 6) & 63) | 128;\n                out[p++] = (c & 63) | 128;\n            }\n        }\n        return new Uint8Array(out);\n    }\n    static utf8ByteArrayToString(bytes) {\n        if (typeof TextDecoder !== 'undefined') {\n            const decoder = new TextDecoder('utf-8');\n            return decoder.decode(bytes);\n        }\n        // Fallback for unsupported TextDecoder.\n        // Note that this fallback can result in a different decoding for invalid utf8 than the native implementation.\n        // This is the case when a character requires more bytes than are left in the array which is not handled here.\n        const out = [];\n        let pos = 0;\n        let c = 0;\n        while (pos < bytes.length) {\n            /* eslint-disable no-mixed-operators */\n            const c1 = bytes[pos++];\n            if (c1 < 128) {\n                out[c++] = String.fromCharCode(c1);\n            }\n            else if (c1 > 191 && c1 < 224) {\n                const c2 = bytes[pos++];\n                out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n            }\n            else if (c1 > 239 && c1 < 365) {\n                // Surrogate Pair\n                const c2 = bytes[pos++];\n                const c3 = bytes[pos++];\n                const c4 = bytes[pos++];\n                const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 0x10000;\n                out[c++] = String.fromCharCode(0xD800 + (u >> 10));\n                out[c++] = String.fromCharCode(0xDC00 + (u & 1023));\n            }\n            else {\n                const c2 = bytes[pos++];\n                const c3 = bytes[pos++];\n                out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n            }\n            /* eslint-enable no-mixed-operators */\n        }\n        return out.join('');\n    }\n    static isValidUtf8(bytes, denyControlCharacters = false) {\n        const controlCharsWhitelist = [\n            0x09,\n            0x0A,\n            0x0D,\n        ];\n        if (typeof TextDecoder !== 'undefined') {\n            try {\n                const decoder = new TextDecoder('utf-8', { fatal: true });\n                const decoded = decoder.decode(bytes); // throws for invalid input\n                if (!denyControlCharacters)\n                    return true;\n                // Search for control characters (utf-8 single byte characters (0x00-0x7F) which are not in the range\n                // 0x20-0x7E (space-tilde)). Note that we use the unicode u flag to avoid astral symbols (symbols\n                // outside the range 0x0000 - 0xFFFF) getting split up into two surrogate halves.\n                // See https://mathiasbynens.be/notes/javascript-unicode#regex\n                // eslint-disable-next-line no-control-regex\n                const controlCharsMatch = decoded.match(/[\\u0000-\\u001F\\u007F]/gu);\n                if (!controlCharsMatch)\n                    return true;\n                return controlCharsMatch.every((char) => controlCharsWhitelist.includes(char.charCodeAt(0)));\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        // Fallback for unsupported TextDecoder\n        let i = 0;\n        while (i < bytes.length) {\n            const bytesLeft = bytes.length - i;\n            const first = bytes[i]; // The byte\n            /* eslint-disable brace-style */\n            if (first <= 0x7F) { // Possible one-byte\n                if (first >= 0x20 /* space */ && first <= 0x7E /* tilde */)\n                    ++i; // non-control chars\n                else if (!denyControlCharacters)\n                    ++i; // it's a control char but we're accepting them\n                else if (controlCharsWhitelist.indexOf(first) > -1)\n                    ++i; // whitelisted control char\n                else\n                    break;\n            }\n            else if (first >= 0xC2 && first <= 0xDF && bytesLeft >= 2) { // Possible two-byte\n                const second = bytes[++i];\n                if (second >= 0x80 && second <= 0xBF)\n                    ++i; // Is valid two-byte\n                else\n                    break;\n            }\n            else if (first === 0xE0 && bytesLeft >= 3) { // Possible three-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                if (second >= 0xA0 && second <= 0xBF\n                    && third >= 0x80 && third <= 0xBF)\n                    ++i; // Is valid three-byte\n                else\n                    break;\n            }\n            else if (first >= 0xE1 && first <= 0xEC && bytesLeft >= 3) { // Possible three-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                if (second >= 0x80 && second <= 0xBF\n                    && third >= 0x80 && third <= 0xBF)\n                    ++i; // Is valid three-byte\n                else\n                    break;\n            }\n            else if (first === 0xED && bytesLeft >= 3) { // Possible three-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                if (second >= 0x80 && second <= 0x9F\n                    && third >= 0x80 && third <= 0xBF)\n                    ++i; // Is valid three-byte\n                else\n                    break;\n            }\n            else if (first >= 0xEE && first <= 0xEF && bytesLeft >= 3) { // Possible three-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                if (second >= 0x80 && second <= 0xBF\n                    && third >= 0x80 && third <= 0xBF)\n                    ++i; // Is valid three-byte\n                else\n                    break;\n            }\n            else if (first === 0xF0 && bytesLeft >= 4) { // Possible four-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                const fourth = bytes[++i];\n                if (second >= 0x90 && second <= 0xBF\n                    && third >= 0x80 && third <= 0xBF\n                    && fourth >= 0x80 && fourth <= 0xBF)\n                    ++i; // Is valid four-byte\n                else\n                    break;\n            }\n            else if (first >= 0xF1 && first <= 0xF3 && bytesLeft >= 4) { // Possible four-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                const fourth = bytes[++i];\n                if (second >= 0x80 && second <= 0xBF\n                    && third >= 0x80 && third <= 0xBF\n                    && fourth >= 0x80 && fourth <= 0xBF)\n                    ++i; // Is valid four-byte\n                else\n                    break;\n            }\n            else if (first === 0xF4 && bytesLeft >= 4) { // Possible four-byte\n                const second = bytes[++i];\n                const third = bytes[++i];\n                const fourth = bytes[++i];\n                if (second >= 0x80 && second <= 0x8F\n                    && third >= 0x80 && third <= 0xBF\n                    && fourth >= 0x80 && fourth <= 0xBF)\n                    ++i; // Is valid four-byte\n                else\n                    break;\n            }\n            else\n                break;\n            /* eslint-enable brace-style */\n        }\n        // If the whole array was walked successfully, then the last check also increased the counter\n        // and the index i is equal to the length of the array.\n        // If the while loop was broken early, i is smaller and the array is not valid UTF-8.\n        return i === bytes.length;\n    }\n    static truncateToUtf8ByteLength(input, length, applyEllipsis = true) {\n        if (length < 0) {\n            throw new Error('Invalid byte length');\n        }\n        let bytes;\n        if (typeof input === 'string') {\n            bytes = Utf8Tools.stringToUtf8ByteArray(input);\n        }\n        else {\n            bytes = input;\n        }\n        if (bytes.length <= length) {\n            return {\n                result: input,\n                didTruncate: false,\n            };\n        }\n        const ellipsisBytes = [226, 128, 166];\n        if (length < ellipsisBytes.length)\n            applyEllipsis = false;\n        bytes = bytes.subarray(0, length - (applyEllipsis ? ellipsisBytes.length : 0));\n        // Cut off last byte until byte array is valid utf-8\n        while (!Utf8Tools.isValidUtf8(bytes))\n            bytes = bytes.subarray(0, bytes.length - 1);\n        if (applyEllipsis) {\n            // Add ellipsis. Note that we can safely extend by the ellipsis bytes as we shoved these bytes off before.\n            bytes = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.length + ellipsisBytes.length);\n            if (typeof input !== 'string') {\n                // We're working on the input bytes. Create a copy to not modify the original data.\n                bytes = new Uint8Array(bytes);\n            }\n            bytes.set(ellipsisBytes, bytes.length - ellipsisBytes.length);\n        }\n        return {\n            result: typeof input === 'string' ? Utf8Tools.utf8ByteArrayToString(bytes) : bytes,\n            didTruncate: true,\n        };\n    }\n}\n\nexport { Utf8Tools };\n//# sourceMappingURL=Utf8Tools.js.map\n"],"names":["Utf8Tools","str","out","p","i","c","bytes","pos","c1","c2","c3","c4","u","denyControlCharacters","controlCharsWhitelist","decoded","controlCharsMatch","char","bytesLeft","first","second","third","fourth","input","length","applyEllipsis","ellipsisBytes"],"mappings":"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"}