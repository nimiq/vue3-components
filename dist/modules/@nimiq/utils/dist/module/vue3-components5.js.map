{"version":3,"file":"vue3-components5.js","sources":["../../../../../../node_modules/@nimiq/utils/dist/module/FiatApi.js"],"sourcesContent":["// Note that coingecko supports many more but these are the ones that are currently of interest to us\nvar FiatApiSupportedCryptoCurrency;\n(function (FiatApiSupportedCryptoCurrency) {\n    FiatApiSupportedCryptoCurrency[\"NIM\"] = \"nim\";\n    FiatApiSupportedCryptoCurrency[\"BTC\"] = \"btc\";\n    FiatApiSupportedCryptoCurrency[\"ETH\"] = \"eth\";\n    FiatApiSupportedCryptoCurrency[\"USDC\"] = \"usdc\";\n})(FiatApiSupportedCryptoCurrency || (FiatApiSupportedCryptoCurrency = {}));\n// Note that coingecko supports more vs_currencies (see https://api.coingecko.com/api/v3/simple/supported_vs_currencies)\n// but also includes crypto currencies and ounces of gold amongst others that are not fiat currencies. This list here\n// has been generated by reducing the vs_currencies to those that are listed as a circulating currency on\n// https://en.wikipedia.org/wiki/List_of_circulating_currencies#List_of_circulating_currencies_by_state_or_territory\n// via the following script:\n//\n// const referenceCurrencySymbols = { ...parsed from Wikipedia as described in CurrencyInfo.ts };\n// const FiatApiSupportedFiatCurrency = { ...as defined below };\n// const supportedVsCurrencies = [ ...as returned by https://api.coingecko.com/api/v3/simple/supported_vs_currencies ]\n//     .map((currency) => currency.toUpperCase());\n// for (const currency of supportedVsCurrencies) {\n//     if (currency in referenceCurrencySymbols && !(currency in FiatApiSupportedFiatCurrency)) {\n//         console.log(`${currency} is a new supported currency`);\n//     }\n// }\n// for (const currency of Object.keys(FiatApiSupportedFiatCurrency)) {\n//     if (!supportedVsCurrencies.includes(currency)) {\n//         console.log(`${currency} is not supported anymore`);\n//     }\n//     if (!(currency in referenceCurrencySymbols)) {\n//         console.log(`${currency} is not a circulating currency anymore`);\n//     }\n// }\nvar FiatApiSupportedFiatCurrency;\n(function (FiatApiSupportedFiatCurrency) {\n    FiatApiSupportedFiatCurrency[\"AED\"] = \"aed\";\n    FiatApiSupportedFiatCurrency[\"ARS\"] = \"ars\";\n    FiatApiSupportedFiatCurrency[\"AUD\"] = \"aud\";\n    FiatApiSupportedFiatCurrency[\"BDT\"] = \"bdt\";\n    FiatApiSupportedFiatCurrency[\"BHD\"] = \"bhd\";\n    FiatApiSupportedFiatCurrency[\"BMD\"] = \"bmd\";\n    FiatApiSupportedFiatCurrency[\"BRL\"] = \"brl\";\n    FiatApiSupportedFiatCurrency[\"CAD\"] = \"cad\";\n    FiatApiSupportedFiatCurrency[\"CHF\"] = \"chf\";\n    FiatApiSupportedFiatCurrency[\"CLP\"] = \"clp\";\n    FiatApiSupportedFiatCurrency[\"CNY\"] = \"cny\";\n    FiatApiSupportedFiatCurrency[\"CZK\"] = \"czk\";\n    FiatApiSupportedFiatCurrency[\"DKK\"] = \"dkk\";\n    FiatApiSupportedFiatCurrency[\"EUR\"] = \"eur\";\n    FiatApiSupportedFiatCurrency[\"GBP\"] = \"gbp\";\n    FiatApiSupportedFiatCurrency[\"HKD\"] = \"hkd\";\n    FiatApiSupportedFiatCurrency[\"HUF\"] = \"huf\";\n    FiatApiSupportedFiatCurrency[\"IDR\"] = \"idr\";\n    FiatApiSupportedFiatCurrency[\"ILS\"] = \"ils\";\n    FiatApiSupportedFiatCurrency[\"INR\"] = \"inr\";\n    FiatApiSupportedFiatCurrency[\"JPY\"] = \"jpy\";\n    FiatApiSupportedFiatCurrency[\"KRW\"] = \"krw\";\n    FiatApiSupportedFiatCurrency[\"KWD\"] = \"kwd\";\n    FiatApiSupportedFiatCurrency[\"LKR\"] = \"lkr\";\n    FiatApiSupportedFiatCurrency[\"MMK\"] = \"mmk\";\n    FiatApiSupportedFiatCurrency[\"MXN\"] = \"mxn\";\n    FiatApiSupportedFiatCurrency[\"MYR\"] = \"myr\";\n    FiatApiSupportedFiatCurrency[\"NOK\"] = \"nok\";\n    FiatApiSupportedFiatCurrency[\"NGN\"] = \"ngn\";\n    FiatApiSupportedFiatCurrency[\"NZD\"] = \"nzd\";\n    FiatApiSupportedFiatCurrency[\"PHP\"] = \"php\";\n    FiatApiSupportedFiatCurrency[\"PKR\"] = \"pkr\";\n    FiatApiSupportedFiatCurrency[\"PLN\"] = \"pln\";\n    FiatApiSupportedFiatCurrency[\"RUB\"] = \"rub\";\n    FiatApiSupportedFiatCurrency[\"SAR\"] = \"sar\";\n    FiatApiSupportedFiatCurrency[\"SEK\"] = \"sek\";\n    FiatApiSupportedFiatCurrency[\"SGD\"] = \"sgd\";\n    FiatApiSupportedFiatCurrency[\"THB\"] = \"thb\";\n    FiatApiSupportedFiatCurrency[\"TRY\"] = \"try\";\n    FiatApiSupportedFiatCurrency[\"TWD\"] = \"twd\";\n    FiatApiSupportedFiatCurrency[\"UAH\"] = \"uah\";\n    FiatApiSupportedFiatCurrency[\"USD\"] = \"usd\";\n    // VEF = 'vef', // Discontinued Venezuelan BolÃ­var Fuerte which was replaced by VES. Rates are completely off.\n    FiatApiSupportedFiatCurrency[\"VND\"] = \"vnd\";\n    FiatApiSupportedFiatCurrency[\"ZAR\"] = \"zar\";\n})(FiatApiSupportedFiatCurrency || (FiatApiSupportedFiatCurrency = {}));\nconst API_URL = 'https://api.coingecko.com/api/v3';\nconst COINGECKO_COIN_IDS = {\n    [FiatApiSupportedCryptoCurrency.NIM]: 'nimiq-2',\n    [FiatApiSupportedCryptoCurrency.BTC]: 'bitcoin',\n    [FiatApiSupportedCryptoCurrency.ETH]: 'ethereum',\n    [FiatApiSupportedCryptoCurrency.USDC]: 'usd-coin',\n};\nconst ONE_MINUTE = 60 * 1000;\nconst ONE_HOUR = 60 * ONE_MINUTE;\nconst ONE_DAY = 24 * ONE_HOUR;\nasync function getExchangeRates(cryptoCurrencies, vsCurrencies) {\n    // Make sure the crypto currencies are lower case so they match the enum (for users that might not be using\n    // typescript which ensures that only valid currency tickers are passed). vsCurrencies do not be to be transformed\n    // because coingecko accepts uppercase and lowercase.\n    cryptoCurrencies = cryptoCurrencies.map((currency) => currency.toLowerCase());\n    const coinIds = cryptoCurrencies.map((currency) => COINGECKO_COIN_IDS[currency]);\n    const apiResult = await _fetch(`${API_URL}/simple/price`\n        + `?ids=${coinIds.join(',')}&vs_currencies=${vsCurrencies.join(',')}`);\n    // Map coingecko coin ids back to FiatApiSupportedCryptoCurrency enum\n    return cryptoCurrencies.reduce((result, cryptoCurrency) => ({\n        ...result,\n        [cryptoCurrency]: apiResult[COINGECKO_COIN_IDS[cryptoCurrency]],\n    }), {});\n}\n/**\n * Request historic exchange rates by range. Note that the time resolution depends on the chosen range. Coingecko\n * provides minutely for ranges within 1 day from the current time, hourly data for any ranges between 1 day and 90 days\n * (do not need to be within 90 days from current time) and daily for ranges above 90 days.\n * Note that minutely data is ~5-10 minutes apart, hourly data about an hour.\n * Input and output timestamps are in milliseconds.\n */\nasync function getHistoricExchangeRatesByRange(cryptoCurrency, vsCurrency, from, // in milliseconds\nto) {\n    const coinId = COINGECKO_COIN_IDS[cryptoCurrency.toLowerCase()];\n    // Note that from and to are expected in seconds but returned timestamps are in ms.\n    from = Math.floor(from / 1000);\n    to = Math.ceil(to / 1000);\n    const { prices: result } = await _fetch(`${API_URL}/coins/${coinId}/market_chart/range`\n        + `?vs_currency=${vsCurrency}&from=${from}&to=${to}`);\n    return result;\n}\n/**\n * Get historic exchange rates at specific timestamps in milliseconds.\n */\nasync function getHistoricExchangeRates(cryptoCurrency, vsCurrency, timestamps, disableMinutlyData = false) {\n    const result = new Map();\n    if (!timestamps.length)\n        return result;\n    // 1. Create chunks.\n    // To get the best possible time resolution, we split the timestamps into a chunk within at most 1 day from now\n    // and the rest into additional 90 day chunks.\n    const now = Date.now();\n    const chunks = [];\n    let timestampIndex = timestamps.length - 1;\n    timestamps.sort((a, b) => a - b);\n    // Create one day chunk\n    if (!disableMinutlyData && now - timestamps[timestamps.length - 1] < ONE_DAY - 15 * ONE_MINUTE) {\n        // Has a timestamp within last day (minus safety margin in case our clock is slightly off).\n        // As one day is calculated from now and not from the timestamp, we have to account for the difference\n        // between now and the timestamp.\n        const maxChunkLength = ONE_DAY - 15 * ONE_MINUTE - (now - timestamps[timestamps.length - 1]);\n        const { chunk, searchEndIndex } = _findTimestampChunk(timestamps, timestampIndex, maxChunkLength, \n        // Prices are 5-10 min apart, chose margin such we get earlier and later data point for interpolation\n        10 * ONE_MINUTE);\n        chunks.push(chunk);\n        timestampIndex = searchEndIndex;\n    }\n    // Create additional 90 day chunks\n    while (timestampIndex >= 0) {\n        const { chunk, searchEndIndex } = _findTimestampChunk(timestamps, timestampIndex, 90 * ONE_DAY, \n        // Prices are ~1h apart, chose margin such we get earlier and later data point for interpolation\n        1.5 * ONE_HOUR);\n        chunks.push(chunk);\n        timestampIndex = searchEndIndex;\n    }\n    // 2. Query Coingecko Api\n    const fetchPromises = chunks.map((chunk) => getHistoricExchangeRatesByRange(cryptoCurrency, vsCurrency, chunk.start, chunk.end));\n    const prices = (await Promise.all(fetchPromises)).reduce((accumulated, singleResult) => [...singleResult, ...accumulated], []).sort((a, b) => a[0] - b[0]); // have to re-sort by timestamp as chunks might be overlapping\n    if (!prices.length)\n        return result; // Happens if coingecko doesn't have data for any of requested timestamps,\n    // for example for days before coingecko started collecting Nim price info or for days in the future.\n    // 3. For every requested timestamp interpolate the price from the timestamps we got from the API\n    timestampIndex = 0;\n    let priceIndex = 0;\n    while (timestampIndex < timestamps.length) {\n        // Search priceIndex at which predecessor price timestamp < our timestamp <= current price timestamp.\n        const timestamp = timestamps[timestampIndex];\n        while (priceIndex < prices.length && prices[priceIndex][0] < timestamp) {\n            ++priceIndex;\n        }\n        if (priceIndex === 0 || priceIndex === prices.length) {\n            // Can't interpolate. This should typically not happen as we try to include additional data points\n            // for interpolation by our choice of _findTimestampChunk margins. However, this can still occur in\n            // exceptional cases when the gap between two data points was larger than our margin or the requested\n            // timestamp was before coingecko even started recording price data or is in the future.\n            const priceEntry = prices[Math.min(priceIndex, prices.length - 1)];\n            if (Math.abs(timestamp - priceEntry[0]) < 2 * ONE_DAY && timestamp <= now) {\n                // Accept the single price entry's price if it's within a limit of 2 days and we're not making\n                // assumptions about the future.\n                result.set(timestamp, priceEntry[1]);\n            }\n        }\n        else {\n            // Interpolate between priceIndex-1 and priceIndex\n            const predecessorEntry = prices[priceIndex - 1];\n            const currentEntry = prices[priceIndex];\n            const timeDelta = currentEntry[0] - predecessorEntry[0];\n            if (timeDelta < 2 * ONE_DAY) {\n                // accept the interpolation if timeDelta is within 2 days (typically should be 1 hour).\n                const priceDelta = currentEntry[1] - predecessorEntry[1];\n                const interpolatedPrice = predecessorEntry[1]\n                    + priceDelta * ((timestamp - predecessorEntry[0]) / timeDelta);\n                result.set(timestamp, interpolatedPrice);\n            }\n        }\n        ++timestampIndex; // Continue with next timestamp and check same priceIndex\n    }\n    return result;\n}\nfunction _findTimestampChunk(timestamps, searchStartIndex, maxChunkLength, timeMargin) {\n    maxChunkLength -= 2 * timeMargin;\n    const end = timestamps[searchStartIndex];\n    let start = end;\n    let i = searchStartIndex - 1;\n    while (i >= 0 && end - timestamps[i] < maxChunkLength) {\n        start = timestamps[i];\n        --i;\n    }\n    return {\n        searchEndIndex: i,\n        chunk: {\n            start: start - timeMargin,\n            end: end + timeMargin,\n        },\n    };\n}\nasync function _fetch(input, init) {\n    let result = null;\n    do {\n        let retry = true;\n        try {\n            // eslint-disable-next-line no-await-in-loop\n            const response = await fetch(input, init); // throws when user is offline\n            if (!response.ok) {\n                if (response.status === 400) {\n                    retry = false;\n                    throw new Error('400 - Bad request');\n                }\n                throw new Error(`Failed to fetch: ${response.status}. Retrying...`);\n            }\n            // eslint-disable-next-line no-await-in-loop\n            result = await response.json();\n        }\n        catch (e) {\n            // User might be offline or we ran into coingecko's rate limiting. Coingecko allows 100 requests\n            // per minute and tells us in the response headers when our next minute starts, but unfortunately\n            // due to cors we can not access this information. Therefore, we blindly retry after waiting some\n            // time. Note that coingecko resets the quota solely based on their system time, i.e. independent\n            // of when we resend our request. Therefore, we do not waste time/part of our quota by waiting a\n            // bit longer. Note however, that we do not prioritize between our fetches, therefore they will\n            // be resolved in random order.\n            if (retry) {\n                // eslint-disable-next-line no-await-in-loop\n                await new Promise((resolve) => setTimeout(resolve, 15000));\n            }\n            else {\n                throw e;\n            }\n        }\n    } while (!result);\n    return result;\n}\n\nexport { FiatApiSupportedCryptoCurrency, FiatApiSupportedFiatCurrency, getExchangeRates, getHistoricExchangeRatesByRange, getHistoricExchangeRates };\n//# sourceMappingURL=FiatApi.js.map\n"],"names":["FiatApiSupportedCryptoCurrency","FiatApiSupportedFiatCurrency","API_URL","COINGECKO_COIN_IDS","getExchangeRates","cryptoCurrencies","vsCurrencies","currency","coinIds","apiResult","_fetch","result","cryptoCurrency","input","init","retry","response","e","resolve"],"mappings":"AACG,IAACA;AAAA,CACH,SAAUA,GAAgC;AACvC,EAAAA,EAA+B,MAAS,OACxCA,EAA+B,MAAS,OACxCA,EAA+B,MAAS,OACxCA,EAA+B,OAAU;AAC7C,GAAGA,MAAmCA,IAAiC,CAAE,EAAC;AAwBvE,IAACC;AAAA,CACH,SAAUA,GAA8B;AACrC,EAAAA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS,OAEtCA,EAA6B,MAAS,OACtCA,EAA6B,MAAS;AAC1C,GAAGA,MAAiCA,IAA+B,CAAE,EAAC;AACtE,MAAMC,IAAU,oCACVC,IAAqB;AAAA,EACvB,CAACH,EAA+B,MAAM;AAAA,EACtC,CAACA,EAA+B,MAAM;AAAA,EACtC,CAACA,EAA+B,MAAM;AAAA,EACtC,CAACA,EAA+B,OAAO;AAC3C;AAIA,eAAeI,EAAiBC,GAAkBC,GAAc;AAI5D,EAAAD,IAAmBA,EAAiB,IAAI,CAACE,MAAaA,EAAS,YAAW,CAAE;AAC5E,QAAMC,IAAUH,EAAiB,IAAI,CAACE,MAAaJ,EAAmBI,EAAS,GACzEE,IAAY,MAAMC,EAAO,GAAGR,sBACpBM,EAAQ,KAAK,GAAG,mBAAmBF,EAAa,KAAK,GAAG,GAAG;AAEzE,SAAOD,EAAiB,OAAO,CAACM,GAAQC,OAAoB;AAAA,IACxD,GAAGD;AAAA,IACH,CAACC,IAAiBH,EAAUN,EAAmBS;AAAA,EACvD,IAAQ,CAAE,CAAA;AACV;AAiHA,eAAeF,EAAOG,GAAOC,GAAM;AAC/B,MAAIH,IAAS;AACb,KAAG;AACC,QAAII,IAAQ;AACZ,QAAI;AAEA,YAAMC,IAAW,MAAM,MAAMH,GAAOC,CAAI;AACxC,UAAI,CAACE,EAAS;AACV,cAAIA,EAAS,WAAW,OACpBD,IAAQ,IACF,IAAI,MAAM,mBAAmB,KAEjC,IAAI,MAAM,oBAAoBC,EAAS,qBAAqB;AAGtE,MAAAL,IAAS,MAAMK,EAAS;IAC3B,SACMC,GAAP;AAQI,UAAIF;AAEA,cAAM,IAAI,QAAQ,CAACG,MAAY,WAAWA,GAAS,IAAK,CAAC;AAAA;AAGzD,cAAMD;AAAA,IAEb;AAAA,EACJ,SAAQ,CAACN;AACV,SAAOA;AACX;"}