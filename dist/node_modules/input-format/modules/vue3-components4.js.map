{"version":3,"file":"vue3-components4.js","sources":["../../../../node_modules/input-format/modules/inputControl.js"],"sourcesContent":["import edit from './edit';\nimport parse from './parse';\nimport format from './format';\nimport { isReadOnly, getOperation, getSelection, getCaretPosition, setCaretPosition } from './dom'; // Deprecated.\n// I don't know why this function exists.\n\nexport function onCut(event, input, _parse, _format, on_change) {\n  if (isReadOnly(input)) {\n    return;\n  } // The actual cut hasn't happened just yet hence the timeout.\n\n\n  setTimeout(function () {\n    return formatInputText(input, _parse, _format, undefined, on_change);\n  }, 0);\n} // Deprecated.\n// I don't know why this function exists.\n\nexport function onPaste(event, input, _parse, _format, on_change) {\n  if (isReadOnly(input)) {\n    return;\n  }\n\n  var selection = getSelection(input); // If selection is made,\n  // just erase the selected text\n  // prior to pasting\n\n  if (selection) {\n    eraseSelection(input, selection);\n  }\n\n  formatInputText(input, _parse, _format, undefined, on_change);\n}\nexport function onChange(event, input, _parse, _format, on_change) {\n  formatInputText(input, _parse, _format, undefined, on_change);\n} // \"Delete\" and \"Backspace\" keys are special\n// in a way that they're not handled by the regular `onChange()` handler\n// and instead are intercepted and re-applied manually.\n// The reason is that normally hitting \"Backspace\" or \"Delete\"\n// results in erasing a character, but that character might be any character,\n// while it would be a better \"user experience\" if it erased not just any character\n// but the closest \"meaningful\" character.\n// For example, if a template is `(xxx) xxx-xxxx`,\n// and the `<input/>` value is `(111) 222-3333`,\n// then, if a user begins erasing the `3333` part via \"Backspace\"\n// and reaches the \"-\" character, then it would just erase the \"-\" character.\n// Nothing wrong with that, but it would be a better \"user experience\"\n// if hitting \"Backspace\" at that position would erase the closest \"meaningful\"\n// character, which would be the rightmost `2`.\n// So, what this `onKeyDown()` handler does is it intercepts\n// \"Backspace\" and \"Delete\" keys and re-applies those operations manually\n// following the logic described above.\n\nexport function onKeyDown(event, input, _parse, _format, on_change) {\n  if (isReadOnly(input)) {\n    return;\n  }\n\n  var operation = getOperation(event);\n\n  switch (operation) {\n    case 'Delete':\n    case 'Backspace':\n      // Intercept this operation and perform it manually.\n      event.preventDefault();\n      var selection = getSelection(input); // If a selection is made, just erase the selected text.\n\n      if (selection) {\n        eraseSelection(input, selection);\n        return formatInputText(input, _parse, _format, undefined, on_change);\n      } // Else, perform the (character erasing) operation manually.\n\n\n      return formatInputText(input, _parse, _format, operation, on_change);\n\n    default: // Will be handled normally as part of the `onChange` handler.\n\n  }\n}\n/**\r\n * Erases the selected text inside an `<input/>`.\r\n * @param  {DOMElement} input\r\n * @param  {Selection} selection\r\n */\n\nfunction eraseSelection(input, selection) {\n  var text = input.value;\n  text = text.slice(0, selection.start) + text.slice(selection.end);\n  input.value = text;\n  setCaretPosition(input, selection.start);\n}\n/**\r\n * Parses and re-formats `<input/>` textual value.\r\n * E.g. when a user enters something into the `<input/>`\r\n * that raw input must first be parsed and the re-formatted properly.\r\n * Is called either after some user input (e.g. entered a character, pasted something)\r\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\r\n * @param  {DOMElement} input\r\n * @param  {Function} parse\r\n * @param  {Function} format\r\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\r\n * @param  {Function} onChange\r\n */\n\n\nfunction formatInputText(input, _parse, _format, operation, on_change) {\n  // Parse `<input/>` textual value.\n  // Get the `value` and `caret` position.\n  var _parse2 = parse(input.value, getCaretPosition(input), _parse),\n      value = _parse2.value,\n      caret = _parse2.caret; // If a user performed an operation (\"Backspace\", \"Delete\")\n  // then apply that operation and get the new `value` and `caret` position.\n\n\n  if (operation) {\n    var newValueAndCaret = edit(value, caret, operation);\n    value = newValueAndCaret.value;\n    caret = newValueAndCaret.caret;\n  } // Format the `value`.\n  // (and reposition the caret accordingly)\n\n\n  var formatted = format(value, caret, _format);\n  var text = formatted.text;\n  caret = formatted.caret; // Set `<input/>` textual value manually\n  // to prevent React from resetting the caret position\n  // later inside a subsequent `render()`.\n  // Doesn't work for custom `inputComponent`s for some reason.\n\n  input.value = text; // Position the caret properly.\n\n  setCaretPosition(input, caret); // If the `<input/>` textual value did change,\n  // then the parsed `value` may have changed too.\n\n  on_change(value);\n}\n//# sourceMappingURL=inputControl.js.map"],"names":["onCut","event","input","_parse","_format","on_change","isReadOnly","formatInputText","onPaste","selection","getSelection","eraseSelection","onChange","onKeyDown","operation","getOperation","text","setCaretPosition","_parse2","parse","getCaretPosition","value","caret","newValueAndCaret","edit","formatted","format"],"mappings":";;;;AAMO,SAASA,EAAMC,GAAOC,GAAOC,GAAQC,GAASC,GAAW;AAC9D,EAAIC,EAAWJ,CAAK,KAKpB,WAAW,WAAY;AACrB,WAAOK,EAAgBL,GAAOC,GAAQC,GAAS,QAAWC,CAAS;AAAA,EACpE,GAAE,CAAC;AACN;AAGO,SAASG,EAAQP,GAAOC,GAAOC,GAAQC,GAASC,GAAW;AAChE,MAAI,CAAAC,EAAWJ,CAAK,GAIpB;AAAA,QAAIO,IAAYC,EAAaR,CAAK;AAIlC,IAAIO,KACFE,EAAeT,GAAOO,CAAS,GAGjCF,EAAgBL,GAAOC,GAAQC,GAAS,QAAWC,CAAS;AAAA;AAC9D;AACO,SAASO,EAASX,GAAOC,GAAOC,GAAQC,GAASC,GAAW;AACjE,EAAAE,EAAgBL,GAAOC,GAAQC,GAAS,QAAWC,CAAS;AAC9D;AAkBO,SAASQ,EAAUZ,GAAOC,GAAOC,GAAQC,GAASC,GAAW;AAClE,MAAI,CAAAC,EAAWJ,CAAK,GAIpB;AAAA,QAAIY,IAAYC,EAAad,CAAK;AAElC,YAAQa,GAAS;AAAA,MACf,KAAK;AAAA,MACL,KAAK;AAEH,QAAAb,EAAM,eAAc;AACpB,YAAIQ,IAAYC,EAAaR,CAAK;AAElC,eAAIO,KACFE,EAAeT,GAAOO,CAAS,GACxBF,EAAgBL,GAAOC,GAAQC,GAAS,QAAWC,CAAS,KAI9DE,EAAgBL,GAAOC,GAAQC,GAASU,GAAWT,CAAS;AAAA,IAItE;AAAA;AACH;AAOA,SAASM,EAAeT,GAAOO,GAAW;AACxC,MAAIO,IAAOd,EAAM;AACjB,EAAAc,IAAOA,EAAK,MAAM,GAAGP,EAAU,KAAK,IAAIO,EAAK,MAAMP,EAAU,GAAG,GAChEP,EAAM,QAAQc,GACdC,EAAiBf,GAAOO,EAAU,KAAK;AACzC;AAeA,SAASF,EAAgBL,GAAOC,GAAQC,GAASU,GAAWT,GAAW;AAGrE,MAAIa,IAAUC,EAAMjB,EAAM,OAAOkB,EAAiBlB,CAAK,GAAGC,CAAM,GAC5DkB,IAAQH,EAAQ,OAChBI,IAAQJ,EAAQ;AAIpB,MAAIJ,GAAW;AACb,QAAIS,IAAmBC,EAAKH,GAAOC,GAAOR,CAAS;AACnD,IAAAO,IAAQE,EAAiB,OACzBD,IAAQC,EAAiB;AAAA,EAC1B;AAID,MAAIE,IAAYC,EAAOL,GAAOC,GAAOlB,CAAO,GACxCY,IAAOS,EAAU;AACrB,EAAAH,IAAQG,EAAU,OAKlBvB,EAAM,QAAQc,GAEdC,EAAiBf,GAAOoB,CAAK,GAG7BjB,EAAUgB,CAAK;AACjB;"}