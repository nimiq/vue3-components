{"version":3,"file":"vue3-components3.js","sources":["../../../../node_modules/input-format/modules/format.js"],"sourcesContent":["import template_formatter from './templateFormatter'; // Formats `value` value preserving `caret` at the same character.\n//\n// `{ value, caret }` attribute is the result of `parse()` function call.\n//\n// Returns `{ text, caret }` where the new `caret` is the caret position\n// inside `text` text corresponding to the original `caret` position inside `value`.\n//\n// `formatter(value)` is a function returning `{ text, template }`.\n//\n// `text` is the `value` value formatted using `template`.\n// It may either cut off the non-filled right part of the `template`\n// or it may fill the non-filled character placeholders\n// in the right part of the `template` with `spacer`\n// which is a space (' ') character by default.\n//\n// `template` is the template used to format the `value`.\n// It can be either a full-length template or a partial template.\n//\n// `formatter` can also be a string â€” a `template`\n// where character placeholders are denoted by 'x'es.\n// In this case `formatter` function is automatically created.\n//\n// Example:\n//\n// `value` is '880',\n// `caret` is `2` (before the first `0`)\n//\n// `formatter` is `'880' =>\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\n//\n// The result is `{ text: '8 (80 )', caret: 4 }`.\n//\n\nexport default function format(value, caret, formatter) {\n  if (typeof formatter === 'string') {\n    formatter = template_formatter(formatter);\n  }\n\n  var _ref = formatter(value) || {},\n      text = _ref.text,\n      template = _ref.template;\n\n  if (text === undefined) {\n    text = value;\n  }\n\n  if (template) {\n    if (caret === undefined) {\n      caret = text.length;\n    } else {\n      var index = 0;\n      var found = false;\n      var possibly_last_input_character_index = -1;\n\n      while (index < text.length && index < template.length) {\n        // Character placeholder found\n        if (text[index] !== template[index]) {\n          if (caret === 0) {\n            found = true;\n            caret = index;\n            break;\n          }\n\n          possibly_last_input_character_index = index;\n          caret--;\n        }\n\n        index++;\n      } // If the caret was positioned after last input character,\n      // then the text caret index is just after the last input character.\n\n\n      if (!found) {\n        caret = possibly_last_input_character_index + 1;\n      }\n    }\n  }\n\n  return {\n    text: text,\n    caret: caret\n  };\n}\n//# sourceMappingURL=format.js.map"],"names":["format","value","caret","formatter","template_formatter","_ref","text","template","index","found","possibly_last_input_character_index"],"mappings":";AAiCe,SAASA,EAAOC,GAAOC,GAAOC,GAAW;AACtD,EAAI,OAAOA,KAAc,aACvBA,IAAYC,EAAmBD,CAAS;AAG1C,MAAIE,IAAOF,EAAUF,CAAK,KAAK,CAAE,GAC7BK,IAAOD,EAAK,MACZE,IAAWF,EAAK;AAMpB,MAJIC,MAAS,WACXA,IAAOL,IAGLM;AACF,QAAIL,MAAU;AACZ,MAAAA,IAAQI,EAAK;AAAA,SACR;AAKL,eAJIE,IAAQ,GACRC,IAAQ,IACRC,IAAsC,IAEnCF,IAAQF,EAAK,UAAUE,IAAQD,EAAS,UAAQ;AAErD,YAAID,EAAKE,OAAWD,EAASC,IAAQ;AACnC,cAAIN,MAAU,GAAG;AACf,YAAAO,IAAQ,IACRP,IAAQM;AACR;AAAA,UACD;AAED,UAAAE,IAAsCF,GACtCN;AAAA,QACD;AAED,QAAAM;AAAA,MACD;AAID,MAAKC,MACHP,IAAQQ,IAAsC;AAAA,IAEjD;AAGH,SAAO;AAAA,IACL,MAAMJ;AAAA,IACN,OAAOJ;AAAA,EACX;AACA;"}